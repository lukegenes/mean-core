var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { AccountLayout, MintLayout, Token, } from '@solana/spl-token';
import { Account, PublicKey, SystemProgram, Transaction, } from '@solana/web3.js';
import { createInitSwapInstruction, DEFAULT_LIQUIDITY_TOKEN_PRECISION, depositInstruction, getProgramVersion, parseMintData, parseTokenAccount, PROGRAM_ID, SWAP_PROGRAM_OWNER_FEE_ADDRESS, swapInstruction, TOKEN_PROGRAM_ID, TokenSwapLayout, withdrawInstruction, WRAPPED_SOL_MINT, } from './instructions';
import { divideBnToNumber, timeMs } from './utils';
import assert from 'assert';
import BN from 'bn.js';
export class Pool {
    constructor(decoded, // todo: remove any
    poolAccount, programId, options = {}) {
        const { skipPreflight = false, commitment = 'recent' } = options;
        this._decoded = decoded;
        this._poolAccount = poolAccount;
        this._programId = programId;
        this._tokenMints = [
            new PublicKey(decoded.mintA),
            new PublicKey(decoded.mintB),
        ];
        this._holdingAccounts = [
            new PublicKey(decoded.tokenAccountA),
            new PublicKey(decoded.tokenAccountB),
        ];
        this._poolTokenMint = new PublicKey(decoded.tokenPool);
        this._feeAccount = new PublicKey(decoded.feeAccount);
        this._skipPreflight = skipPreflight;
        this._commitment = commitment;
        this._mintAccountsCache = {};
        this._tokenAccountsCache = {};
    }
    static load(connection, address, programId, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const account = throwIfNull(yield connection.getAccountInfo(address), 'Pool not found');
            const decoded = TokenSwapLayout.decode(account.data);
            return new Pool(decoded, address, programId, options);
        });
    }
    get address() {
        return this._poolAccount;
    }
    get publicKey() {
        return this.address;
    }
    get programVersion() {
        return getProgramVersion(this._programId);
    }
    cached(callable, cache, key, cacheDurationMs) {
        return __awaiter(this, void 0, void 0, function* () {
            const cachedItem = cache[key];
            const now = timeMs();
            if (cachedItem && now - cachedItem.ts < cacheDurationMs) {
                return cachedItem.value;
            }
            const value = yield callable();
            cache[key] = {
                value,
                ts: now,
            };
            return value;
        });
    }
    getCachedMintAccount(connection, pubkey, cacheDurationMs = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.cached(() => getMintAccount(connection, pubkey), this._mintAccountsCache, typeof pubkey === 'string' ? pubkey : pubkey.toBase58(), cacheDurationMs);
        });
    }
    getCachedTokenAccount(connection, pubkey, cacheDurationMs = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.cached(() => getTokenAccount(connection, pubkey), this._tokenAccountsCache, typeof pubkey === 'string' ? pubkey : pubkey.toBase58(), cacheDurationMs);
        });
    }
    makeRemoveLiquidityTransaction(connection, owner, liquidityAmount, poolAccount, tokenAccounts) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            // @ts-ignore
            const ownerAddress = (_a = owner.publicKey) !== null && _a !== void 0 ? _a : owner;
            // TODO get min amounts based on total supply and liquidity
            const minAmount0 = 0;
            const minAmount1 = 0;
            const poolMint = yield this.getCachedMintAccount(connection, this._poolTokenMint, 3600000);
            const accountA = yield this.getCachedTokenAccount(connection, this._holdingAccounts[0], 3600000);
            const accountB = yield this.getCachedTokenAccount(connection, this._holdingAccounts[1], 3600000);
            if (!poolMint.mintAuthority) {
                throw new Error('Mint doesnt have authority');
            }
            const authority = poolMint.mintAuthority;
            const signers = [];
            const instructions = [];
            const cleanUpInstructions = [];
            let tokenAccountA;
            let tokenAccountB;
            if (accountA.info.mint.equals(WRAPPED_SOL_MINT)) {
                const accountRentExempt = yield connection.getMinimumBalanceForRentExemption(AccountLayout.span);
                const { account, instructions, cleanUpInstructions } = createTokenAccount(ownerAddress, ownerAddress, WRAPPED_SOL_MINT, accountRentExempt);
                tokenAccountA = account.publicKey;
                signers.push(account);
                instructions.concat(instructions);
                cleanUpInstructions.concat(cleanUpInstructions);
            }
            else {
                tokenAccountA = (_b = tokenAccounts.find(a => a.info.mint.equals(accountA.info.mint))) === null || _b === void 0 ? void 0 : _b.pubkey;
            }
            if (accountB.info.mint.equals(WRAPPED_SOL_MINT)) {
                const accountRentExempt = yield connection.getMinimumBalanceForRentExemption(AccountLayout.span);
                const { account, instructions, cleanUpInstructions } = createTokenAccount(ownerAddress, ownerAddress, WRAPPED_SOL_MINT, accountRentExempt);
                tokenAccountB = account.publicKey;
                signers.push(account);
                instructions.concat(instructions);
                cleanUpInstructions.concat(cleanUpInstructions);
            }
            else {
                tokenAccountB = (_c = tokenAccounts.find(a => a.info.mint.equals(accountB.info.mint))) === null || _c === void 0 ? void 0 : _c.pubkey;
            }
            assert(!!tokenAccountA, `Token account for mint ${accountA.info.mint.toBase58()} not provided`);
            assert(!!tokenAccountB, `Token account for mint ${accountB.info.mint.toBase58()} not provided`);
            instructions.push(Token.createApproveInstruction(TOKEN_PROGRAM_ID, poolAccount.pubkey, authority, ownerAddress, [], liquidityAmount));
            instructions.push(withdrawInstruction(this._poolAccount, authority, this._poolTokenMint, this._feeAccount, poolAccount.pubkey, this._holdingAccounts[0], this._holdingAccounts[1], tokenAccountA, tokenAccountB, this._programId, TOKEN_PROGRAM_ID, liquidityAmount, minAmount0, minAmount1));
            const transaction = new Transaction();
            transaction.add(...instructions, ...cleanUpInstructions);
            return { transaction, signers, payer: owner };
        });
    }
    makeAddLiquidityTransaction(connection, owner, sourceTokenAccounts, poolTokenAccount, slippageTolerance = 0.005) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // @ts-ignore
            const ownerAddress = (_a = owner.publicKey) !== null && _a !== void 0 ? _a : owner;
            const poolMint = yield this.getCachedMintAccount(connection, this._poolTokenMint, 360000);
            if (!poolMint.mintAuthority) {
                throw new Error('Mint doesnt have authority');
            }
            if (!this._feeAccount) {
                throw new Error('Invald fee account');
            }
            const accountA = yield this.getCachedTokenAccount(connection, this._holdingAccounts[0]);
            const accountB = yield this.getCachedTokenAccount(connection, this._holdingAccounts[1]);
            const reserve0 = accountA.info.amount.toNumber();
            const reserve1 = accountB.info.amount.toNumber();
            const [fromA, fromB] = accountA.info.mint.equals(sourceTokenAccounts[0].mint)
                ? [sourceTokenAccounts[0], sourceTokenAccounts[1]]
                : [sourceTokenAccounts[1], sourceTokenAccounts[0]];
            if (!fromA.tokenAccount || !fromB.tokenAccount) {
                throw new Error('Missing account info.');
            }
            const supply = poolMint.supply.toNumber();
            const authority = poolMint.mintAuthority;
            // Uniswap whitepaper: https://uniswap.org/whitepaper.pdf
            // see: https://uniswap.org/docs/v2/advanced-topics/pricing/
            // as well as native uniswap v2 oracle: https://uniswap.org/docs/v2/core-concepts/oracles/
            const amount0 = fromA.amount;
            const amount1 = fromB.amount;
            const liquidity = Math.min((amount0 * (1 - slippageTolerance) * supply) / reserve0, (amount1 * (1 - slippageTolerance) * supply) / reserve1);
            const instructions = [];
            const cleanupInstructions = [];
            const signers = [];
            const accountRentExempt = yield connection.getMinimumBalanceForRentExemption(AccountLayout.span);
            let fromKeyA;
            if (fromA.mint.equals(WRAPPED_SOL_MINT)) {
                const { account, instructions: createWrappedSolInstructions, cleanUpInstructions: removeWrappedSolInstructions, } = createTokenAccount(ownerAddress, ownerAddress, WRAPPED_SOL_MINT, fromA.amount + accountRentExempt);
                fromKeyA = account.publicKey;
                signers.push(account);
                instructions.push(...createWrappedSolInstructions);
                cleanupInstructions.push(...removeWrappedSolInstructions);
            }
            else {
                fromKeyA = fromA.tokenAccount;
            }
            let fromKeyB;
            if (fromB.mint.equals(WRAPPED_SOL_MINT)) {
                const { account, instructions: createWrappedSolInstructions, cleanUpInstructions: removeWrappedSolInstructions, } = createTokenAccount(ownerAddress, ownerAddress, WRAPPED_SOL_MINT, fromB.amount + accountRentExempt);
                fromKeyB = account.publicKey;
                signers.push(account);
                instructions.push(...createWrappedSolInstructions);
                cleanupInstructions.push(...removeWrappedSolInstructions);
            }
            else {
                fromKeyB = fromB.tokenAccount;
            }
            let toAccount;
            if (!poolTokenAccount) {
                const { account, instructions: createToAccountInstructions, cleanUpInstructions: cleanupCreateToAccountInstructions, } = createTokenAccount(ownerAddress, ownerAddress, this._poolTokenMint, accountRentExempt);
                toAccount = account.publicKey;
                signers.push(account);
                instructions.push(...createToAccountInstructions);
                cleanupInstructions.push(...cleanupCreateToAccountInstructions);
            }
            else {
                toAccount = poolTokenAccount;
            }
            // create approval for transfer transactions
            instructions.push(Token.createApproveInstruction(TOKEN_PROGRAM_ID, fromKeyA, authority, ownerAddress, [], amount0));
            instructions.push(Token.createApproveInstruction(TOKEN_PROGRAM_ID, fromKeyB, authority, ownerAddress, [], amount1));
            instructions.push(depositInstruction(this._poolAccount, authority, fromKeyA, fromKeyB, this._holdingAccounts[0], this._holdingAccounts[1], this._poolTokenMint, toAccount, this._programId, TOKEN_PROGRAM_ID, liquidity, amount0, amount1));
            const transaction = new Transaction();
            transaction.add(...instructions);
            transaction.add(...cleanupInstructions);
            return { transaction, signers, payer: owner };
        });
    }
    makeSwapTransaction(connection, owner, tokenIn, tokenOut, slippage, hostFeeAccount) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // @ts-ignore
            const ownerAddress = (_a = owner.publicKey) !== null && _a !== void 0 ? _a : owner;
            const [poolMint, inMint, outMint] = yield Promise.all([
                this.getCachedMintAccount(connection, this._poolTokenMint, 3600000),
                this.getCachedMintAccount(connection, tokenIn.mint, 3600000),
                this.getCachedMintAccount(connection, tokenOut.mint, 3600000),
            ]);
            const amountIn = Math.floor(tokenIn.amount * Math.pow(10, inMint.decimals));
            const minAmountOut = Math.floor(tokenOut.amount * Math.pow(10, outMint.decimals) * (1 - slippage));
            const holdingA = this._tokenMints[0].toBase58() === tokenIn.mint.toBase58()
                ? this._holdingAccounts[0]
                : this._holdingAccounts[1];
            const holdingB = holdingA.equals(this._holdingAccounts[0])
                ? this._holdingAccounts[1]
                : this._holdingAccounts[0];
            if (!poolMint.mintAuthority || !this._feeAccount) {
                throw new Error('Mint doesnt have authority');
            }
            const authority = poolMint.mintAuthority;
            const instructions = [];
            const cleanupInstructions = [];
            const signers = [];
            const accountRentExempt = yield connection.getMinimumBalanceForRentExemption(AccountLayout.span);
            let fromAccount;
            if (tokenIn.mint.equals(WRAPPED_SOL_MINT)) {
                const { account, instructions: createWrappedSolInstructions, cleanUpInstructions: removeWrappedSolInstructions, } = createTokenAccount(ownerAddress, ownerAddress, WRAPPED_SOL_MINT, amountIn + accountRentExempt);
                fromAccount = account.publicKey;
                signers.push(account);
                instructions.push(...createWrappedSolInstructions);
                cleanupInstructions.push(...removeWrappedSolInstructions);
            }
            else {
                fromAccount = tokenIn.tokenAccount;
            }
            let toAccount;
            if (tokenOut.mint.equals(WRAPPED_SOL_MINT)) {
                const { account, instructions: createWrappedSolInstructions, cleanUpInstructions: removeWrappedSolInstructions, } = createTokenAccount(ownerAddress, ownerAddress, WRAPPED_SOL_MINT, accountRentExempt);
                toAccount = account.publicKey;
                signers.push(account);
                instructions.push(...createWrappedSolInstructions);
                cleanupInstructions.push(...removeWrappedSolInstructions);
            }
            else {
                toAccount = tokenOut.tokenAccount;
            }
            // create approval for transfer transactions
            const approveInstruction = Token.createApproveInstruction(TOKEN_PROGRAM_ID, fromAccount, authority, ownerAddress, [], amountIn);
            instructions.push(approveInstruction);
            // swap
            instructions.push(swapInstruction(this._poolAccount, authority, fromAccount, holdingA, holdingB, toAccount, this._poolTokenMint, this._feeAccount, PROGRAM_ID, TOKEN_PROGRAM_ID, amountIn, minAmountOut, hostFeeAccount));
            instructions.push(...cleanupInstructions);
            const transaction = new Transaction();
            transaction.add(...instructions);
            return { transaction, signers, payer: owner };
        });
    }
    swap(connection, owner, tokenIn, tokenOut, slippage, hostFeeAccount, skipPreflight = true, commitment = 'single') {
        return __awaiter(this, void 0, void 0, function* () {
            const { transaction, signers, payer } = yield this.makeSwapTransaction(connection, owner, tokenIn, tokenOut, slippage, hostFeeAccount);
            return yield sendTransaction(connection, transaction, [payer, ...signers], skipPreflight, commitment);
        });
    }
    static makeInitializePoolTransaction(connection, owner, componentMints, sourceTokenAccounts, options, liquidityTokenPrecision = DEFAULT_LIQUIDITY_TOKEN_PRECISION) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // @ts-ignore
            const ownerAddress = (_a = owner.publicKey) !== null && _a !== void 0 ? _a : owner;
            const initializeAccountsInstructions = [];
            const initializeAccountsSigners = [];
            const liquidityTokenMintAccount = new Account();
            initializeAccountsInstructions.push(SystemProgram.createAccount({
                fromPubkey: ownerAddress,
                newAccountPubkey: liquidityTokenMintAccount.publicKey,
                lamports: yield connection.getMinimumBalanceForRentExemption(MintLayout.span),
                space: MintLayout.span,
                programId: TOKEN_PROGRAM_ID,
            }));
            initializeAccountsSigners.push(liquidityTokenMintAccount);
            const tokenSwapAccount = new Account();
            const [authority, nonce] = yield PublicKey.findProgramAddress([tokenSwapAccount.publicKey.toBuffer()], PROGRAM_ID);
            // create mint for pool liquidity token
            initializeAccountsInstructions.push(Token.createInitMintInstruction(TOKEN_PROGRAM_ID, liquidityTokenMintAccount.publicKey, liquidityTokenPrecision, 
            // pass control of liquidity mint to swap program
            authority, 
            // swap program can freeze liquidity token mint
            null));
            const accountRentExempt = yield connection.getMinimumBalanceForRentExemption(AccountLayout.span);
            const holdingAccounts = {};
            componentMints.forEach(mint => {
                const { account, instructions: createHoldingTokenAccountInstructions, } = createTokenAccount(authority, ownerAddress, mint, accountRentExempt);
                initializeAccountsInstructions.push(...createHoldingTokenAccountInstructions);
                initializeAccountsSigners.push(account);
                holdingAccounts[mint.toBase58()] = account;
            });
            const { account: depositorAccount, instructions: createLPTokenAccountInstructions, } = createTokenAccount(ownerAddress, ownerAddress, liquidityTokenMintAccount.publicKey, accountRentExempt);
            initializeAccountsSigners.push(depositorAccount);
            initializeAccountsInstructions.push(...createLPTokenAccountInstructions);
            const { account: feeAccount, instructions: createFeeAccountInstructions, } = createTokenAccount(SWAP_PROGRAM_OWNER_FEE_ADDRESS, ownerAddress, liquidityTokenMintAccount.publicKey, accountRentExempt);
            initializeAccountsSigners.push(feeAccount);
            initializeAccountsInstructions.push(...createFeeAccountInstructions);
            const initializeAccountsTransaction = new Transaction();
            initializeAccountsTransaction.add(...initializeAccountsInstructions);
            // break up these into two transactions because it does not fit in a single transaction
            const initializePoolSigners = [];
            const initializePoolInstructions = [];
            const cleanupInstructions = [];
            initializePoolInstructions.push(SystemProgram.createAccount({
                fromPubkey: ownerAddress,
                newAccountPubkey: tokenSwapAccount.publicKey,
                lamports: yield connection.getMinimumBalanceForRentExemption(TokenSwapLayout.span),
                space: TokenSwapLayout.span,
                programId: PROGRAM_ID,
            }));
            sourceTokenAccounts.forEach(({ mint, tokenAccount, amount }) => {
                let wrappedAccount;
                if (mint.equals(WRAPPED_SOL_MINT)) {
                    const { account, instructions: createWrappedSolInstructions, cleanUpInstructions: removeWrappedSolInstructions, } = createTokenAccount(ownerAddress, ownerAddress, WRAPPED_SOL_MINT, amount + accountRentExempt);
                    wrappedAccount = account.publicKey;
                    initializePoolSigners.push(account);
                    initializePoolInstructions.push(...createWrappedSolInstructions);
                    cleanupInstructions.push(...removeWrappedSolInstructions);
                }
                else {
                    wrappedAccount = tokenAccount;
                }
                initializePoolInstructions.push(Token.createTransferInstruction(TOKEN_PROGRAM_ID, wrappedAccount, holdingAccounts[mint.toBase58()].publicKey, ownerAddress, [], amount));
            });
            initializePoolInstructions.push(createInitSwapInstruction(tokenSwapAccount, authority, holdingAccounts[sourceTokenAccounts[0].mint.toBase58()].publicKey, holdingAccounts[sourceTokenAccounts[1].mint.toBase58()].publicKey, liquidityTokenMintAccount.publicKey, feeAccount.publicKey, depositorAccount.publicKey, TOKEN_PROGRAM_ID, PROGRAM_ID, nonce, options.curveType, options.tradeFeeNumerator, options.tradeFeeDenominator, options.ownerTradeFeeNumerator, options.ownerTradeFeeDenominator, options.ownerWithdrawFeeNumerator, options.ownerWithdrawFeeDenominator));
            initializePoolSigners.push(tokenSwapAccount);
            const initializePoolTransaction = new Transaction();
            initializePoolTransaction.add(...initializePoolInstructions, ...cleanupInstructions);
            return {
                initializeAccountsTransaction,
                initializeAccountsSigners,
                initializePoolTransaction,
                initializePoolSigners,
            };
        });
    }
    static initializePool(connection, owner, componentMints, sourceTokenAccounts, options, liquidityTokenPrecision = DEFAULT_LIQUIDITY_TOKEN_PRECISION, skipPreflight = true, commitment = 'single') {
        return __awaiter(this, void 0, void 0, function* () {
            const { initializeAccountsTransaction, initializeAccountsSigners, initializePoolTransaction, initializePoolSigners, } = yield Pool.makeInitializePoolTransaction(connection, owner, componentMints, sourceTokenAccounts, options, liquidityTokenPrecision);
            const createAccountsTxid = yield sendTransaction(connection, initializeAccountsTransaction, [owner, ...initializeAccountsSigners], skipPreflight, commitment);
            const status = (yield connection.confirmTransaction(createAccountsTxid))
                .value;
            assert(!status.err, `Received error awaiting create accounts transaction ${createAccountsTxid}`);
            return yield sendTransaction(connection, initializePoolTransaction, [owner, ...initializePoolSigners], skipPreflight, commitment);
        });
    }
    getHoldings(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            const accounts = yield Promise.all([
                this.getCachedTokenAccount(connection, this._holdingAccounts[0]),
                this.getCachedTokenAccount(connection, this._holdingAccounts[1]),
            ]);
            return accounts.map(account => {
                return {
                    account: account.pubkey,
                    mint: account.info.mint,
                    holding: account.info.amount,
                };
            });
        });
    }
    get fees() {
        return {
            tradeFee: divideBnToNumber(new BN(this._decoded.tradeFeeNumerator, 'le'), new BN(this._decoded.tradeFeeDenominator, 'le')),
            ownerFee: divideBnToNumber(new BN(this._decoded.ownerTradeFeeNumerator, 'le'), new BN(this._decoded.ownerTradeFeeDenominator, 'le')),
            withdrawFee: divideBnToNumber(new BN(this._decoded.ownerWithdrawFeeNumerator, 'le'), new BN(this._decoded.ownerWithdrawFeeDenominator, 'le')),
        };
    }
}
function sendTransaction(connection, transaction, signers, skipPreflight = true, commitment = 'single') {
    return __awaiter(this, void 0, void 0, function* () {
        const signature = yield connection.sendTransaction(transaction, signers, {
            skipPreflight: skipPreflight,
        });
        const { value } = yield connection.confirmTransaction(signature, commitment);
        if (value === null || value === void 0 ? void 0 : value.err) {
            throw new Error(JSON.stringify(value.err));
        }
        return signature;
    });
}
export const getMintAccount = (connection, pubKey) => __awaiter(void 0, void 0, void 0, function* () {
    const address = typeof pubKey === 'string' ? new PublicKey(pubKey) : pubKey;
    const info = yield connection.getAccountInfo(address);
    if (info === null) {
        throw new Error('Failed to find mint account');
    }
    return parseMintData(info.data);
});
export const getTokenAccount = (connection, pubKey) => __awaiter(void 0, void 0, void 0, function* () {
    const address = typeof pubKey === 'string' ? new PublicKey(pubKey) : pubKey;
    const info = yield connection.getAccountInfo(address);
    if (info === null) {
        throw new Error('Failed to find token account');
    }
    const accountInfo = parseTokenAccount(info.data);
    return {
        pubkey: address,
        account: info,
        info: accountInfo,
    };
});
export const createTokenAccount = (owner, payer, mint, lamports) => {
    const account = new Account();
    const instructions = [];
    const cleanUpInstructions = [];
    const space = AccountLayout.span;
    instructions.push(SystemProgram.createAccount({
        fromPubkey: payer,
        newAccountPubkey: account.publicKey,
        lamports,
        space,
        programId: TOKEN_PROGRAM_ID,
    }));
    instructions.push(Token.createInitAccountInstruction(TOKEN_PROGRAM_ID, mint, account.publicKey, owner));
    if (mint.equals(WRAPPED_SOL_MINT)) {
        cleanUpInstructions.push(Token.createCloseAccountInstruction(TOKEN_PROGRAM_ID, account.publicKey, payer, owner, []));
    }
    return { account, instructions, cleanUpInstructions };
};
function throwIfNull(value, message = 'account not found') {
    if (value === null) {
        throw new Error(message);
    }
    return value;
}
//# sourceMappingURL=pools.js.map