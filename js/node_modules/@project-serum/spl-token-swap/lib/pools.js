"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTokenAccount = exports.approveTransfer = exports.getTokenAccount = exports.getMintAccount = exports.Pool = void 0;
const spl_token_1 = require("@solana/spl-token");
const web3_js_1 = require("@solana/web3.js");
const instructions_1 = require("./instructions");
const utils_1 = require("./utils");
const assert_1 = __importDefault(require("assert"));
const bn_js_1 = __importDefault(require("bn.js"));
class Pool {
    constructor(decoded, // todo: remove any
    poolAccount, programId, options = {}) {
        const { skipPreflight = false, commitment = 'recent' } = options;
        this._decoded = decoded;
        this._poolAccount = poolAccount;
        this._programId = programId;
        this._tokenMints = [decoded.mintA, decoded.mintB];
        this._holdingAccounts = [decoded.tokenAccountA, decoded.tokenAccountB];
        this._poolTokenMint = decoded.tokenPool;
        this._feeAccount = decoded.feeAccount;
        this._skipPreflight = skipPreflight;
        this._commitment = commitment;
        this._mintAccountsCache = {};
        this._tokenAccountsCache = {};
    }
    static async load(connection, address, programId, options = {}) {
        const account = throwIfNull(await connection.getAccountInfo(address), 'Pool not found');
        const layout = instructions_1.getLayoutForProgramId(programId);
        const decoded = layout.decode(account.data);
        return new Pool(decoded, address, programId, options);
    }
    get address() {
        return this._poolAccount;
    }
    get publicKey() {
        return this.address;
    }
    get programVersion() {
        return instructions_1.getProgramVersion(this._programId);
    }
    get programId() {
        return this._programId;
    }
    get isLatest() {
        return instructions_1.getProgramVersion(this._programId) === instructions_1.LATEST_VERSION;
    }
    get poolTokenMint() {
        return this._poolTokenMint;
    }
    get holdingAccounts() {
        return this._holdingAccounts;
    }
    get tokenMints() {
        return this._tokenMints;
    }
    get feeAccount() {
        return this._feeAccount;
    }
    async cached(callable, cache, key, cacheDurationMs) {
        const cachedItem = cache[key];
        const now = utils_1.timeMs();
        if (cachedItem && now - cachedItem.ts < cacheDurationMs) {
            return cachedItem.value;
        }
        const value = await callable();
        cache[key] = {
            value,
            ts: now,
        };
        return value;
    }
    async getCachedMintAccount(connection, pubkey, cacheDurationMs = 0) {
        return this.cached(() => exports.getMintAccount(connection, pubkey), this._mintAccountsCache, typeof pubkey === 'string' ? pubkey : pubkey.toBase58(), cacheDurationMs);
    }
    async getCachedTokenAccount(connection, pubkey, cacheDurationMs = 0) {
        return this.cached(() => exports.getTokenAccount(connection, pubkey), this._tokenAccountsCache, typeof pubkey === 'string' ? pubkey : pubkey.toBase58(), cacheDurationMs);
    }
    async makeRemoveLiquidityTransaction(connection, owner, liquidityAmount, poolAccount, tokenAccounts) {
        var _a, _b, _c;
        // @ts-ignore
        const ownerAddress = (_a = owner.publicKey) !== null && _a !== void 0 ? _a : owner;
        // TODO get min amounts based on total supply and liquidity
        const minAmount0 = 0;
        const minAmount1 = 0;
        const poolMint = await this.getCachedMintAccount(connection, this._poolTokenMint, 3600000);
        const accountA = await this.getCachedTokenAccount(connection, this._holdingAccounts[0], 3600000);
        const accountB = await this.getCachedTokenAccount(connection, this._holdingAccounts[1], 3600000);
        if (!poolMint.mintAuthority) {
            throw new Error('Mint doesnt have authority');
        }
        const authority = poolMint.mintAuthority;
        const signers = [];
        const instructions = [];
        const cleanUpInstructions = [];
        let tokenAccountA;
        let tokenAccountB;
        if (accountA.info.mint.equals(instructions_1.WRAPPED_SOL_MINT)) {
            const accountRentExempt = await connection.getMinimumBalanceForRentExemption(spl_token_1.AccountLayout.span);
            const { account, instructions: createWrappedSolInstructions, cleanUpInstructions: removeWrappedSolInstructions, } = exports.createTokenAccount(ownerAddress, ownerAddress, instructions_1.WRAPPED_SOL_MINT, accountRentExempt);
            tokenAccountA = account.publicKey;
            signers.push(account);
            instructions.push(...createWrappedSolInstructions);
            cleanUpInstructions.push(...removeWrappedSolInstructions);
        }
        else {
            tokenAccountA = (_b = tokenAccounts.find(a => a.info.mint.equals(accountA.info.mint))) === null || _b === void 0 ? void 0 : _b.pubkey;
        }
        if (accountB.info.mint.equals(instructions_1.WRAPPED_SOL_MINT)) {
            const accountRentExempt = await connection.getMinimumBalanceForRentExemption(spl_token_1.AccountLayout.span);
            const { account, instructions: createWrappedSolInstructions, cleanUpInstructions: removeWrappedSolInstructions, } = exports.createTokenAccount(ownerAddress, ownerAddress, instructions_1.WRAPPED_SOL_MINT, accountRentExempt);
            tokenAccountB = account.publicKey;
            signers.push(account);
            instructions.push(...createWrappedSolInstructions);
            cleanUpInstructions.push(...removeWrappedSolInstructions);
        }
        else {
            tokenAccountB = (_c = tokenAccounts.find(a => a.info.mint.equals(accountB.info.mint))) === null || _c === void 0 ? void 0 : _c.pubkey;
        }
        assert_1.default(!!tokenAccountA, `Token account for mint ${accountA.info.mint.toBase58()} not provided`);
        assert_1.default(!!tokenAccountB, `Token account for mint ${accountB.info.mint.toBase58()} not provided`);
        const transferAuthority = exports.approveTransfer(instructions, cleanUpInstructions, poolAccount.pubkey, ownerAddress, liquidityAmount, this.isLatest ? undefined : authority);
        if (this.isLatest) {
            signers.push(transferAuthority);
        }
        instructions.push(instructions_1.withdrawInstruction(this._poolAccount, authority, transferAuthority.publicKey, this._poolTokenMint, this._feeAccount, poolAccount.pubkey, this._holdingAccounts[0], this._holdingAccounts[1], tokenAccountA, tokenAccountB, this._programId, instructions_1.TOKEN_PROGRAM_ID, liquidityAmount, minAmount0, minAmount1));
        const transaction = new web3_js_1.Transaction();
        transaction.add(...instructions, ...cleanUpInstructions);
        return { transaction, signers, payer: owner };
    }
    async makeAddLiquidityTransaction(connection, owner, sourceTokenAccounts, poolTokenAccount, slippageTolerance = 0.005) {
        var _a;
        // @ts-ignore
        const ownerAddress = (_a = owner.publicKey) !== null && _a !== void 0 ? _a : owner;
        const poolMint = await this.getCachedMintAccount(connection, this._poolTokenMint, 360000);
        if (!poolMint.mintAuthority) {
            throw new Error('Mint doesnt have authority');
        }
        if (!this._feeAccount) {
            throw new Error('Invald fee account');
        }
        const accountA = await this.getCachedTokenAccount(connection, this._holdingAccounts[0]);
        const accountB = await this.getCachedTokenAccount(connection, this._holdingAccounts[1]);
        const reserve0 = accountA.info.amount.toNumber();
        const reserve1 = accountB.info.amount.toNumber();
        const [fromA, fromB] = accountA.info.mint.equals(sourceTokenAccounts[0].mint)
            ? [sourceTokenAccounts[0], sourceTokenAccounts[1]]
            : [sourceTokenAccounts[1], sourceTokenAccounts[0]];
        if (!fromA.tokenAccount || !fromB.tokenAccount) {
            throw new Error('Missing account info.');
        }
        const supply = poolMint.supply.toNumber();
        const authority = poolMint.mintAuthority;
        // Uniswap whitepaper: https://uniswap.org/whitepaper.pdf
        // see: https://uniswap.org/docs/v2/advanced-topics/pricing/
        // as well as native uniswap v2 oracle: https://uniswap.org/docs/v2/core-concepts/oracles/
        const amount0 = fromA.amount;
        const amount1 = fromB.amount;
        const liquidity = Math.min((amount0 * (1 - slippageTolerance) * supply) / reserve0, (amount1 * (1 - slippageTolerance) * supply) / reserve1);
        const instructions = [];
        const cleanupInstructions = [];
        const signers = [];
        const accountRentExempt = await connection.getMinimumBalanceForRentExemption(spl_token_1.AccountLayout.span);
        let fromKeyA;
        if (fromA.mint.equals(instructions_1.WRAPPED_SOL_MINT)) {
            const { account, instructions: createWrappedSolInstructions, cleanUpInstructions: removeWrappedSolInstructions, } = exports.createTokenAccount(ownerAddress, ownerAddress, instructions_1.WRAPPED_SOL_MINT, fromA.amount + accountRentExempt);
            fromKeyA = account.publicKey;
            signers.push(account);
            instructions.push(...createWrappedSolInstructions);
            cleanupInstructions.push(...removeWrappedSolInstructions);
        }
        else {
            fromKeyA = fromA.tokenAccount;
        }
        let fromKeyB;
        if (fromB.mint.equals(instructions_1.WRAPPED_SOL_MINT)) {
            const { account, instructions: createWrappedSolInstructions, cleanUpInstructions: removeWrappedSolInstructions, } = exports.createTokenAccount(ownerAddress, ownerAddress, instructions_1.WRAPPED_SOL_MINT, fromB.amount + accountRentExempt);
            fromKeyB = account.publicKey;
            signers.push(account);
            instructions.push(...createWrappedSolInstructions);
            cleanupInstructions.push(...removeWrappedSolInstructions);
        }
        else {
            fromKeyB = fromB.tokenAccount;
        }
        let toAccount;
        if (!poolTokenAccount) {
            const { account, instructions: createToAccountInstructions, cleanUpInstructions: cleanupCreateToAccountInstructions, } = exports.createTokenAccount(ownerAddress, ownerAddress, this._poolTokenMint, accountRentExempt);
            toAccount = account.publicKey;
            signers.push(account);
            instructions.push(...createToAccountInstructions);
            cleanupInstructions.push(...cleanupCreateToAccountInstructions);
        }
        else {
            toAccount = poolTokenAccount;
        }
        // create approval for transfer transactions
        const transferAuthority = exports.approveTransfer(instructions, cleanupInstructions, fromKeyA, ownerAddress, amount0, this.isLatest ? undefined : authority);
        if (this.isLatest) {
            signers.push(transferAuthority);
        }
        exports.approveTransfer(instructions, cleanupInstructions, fromKeyB, ownerAddress, amount1, this.isLatest ? transferAuthority.publicKey : authority);
        instructions.push(instructions_1.depositInstruction(this._poolAccount, authority, transferAuthority.publicKey, fromKeyA, fromKeyB, this._holdingAccounts[0], this._holdingAccounts[1], this._poolTokenMint, toAccount, this._programId, instructions_1.TOKEN_PROGRAM_ID, liquidity, amount0, amount1));
        const transaction = new web3_js_1.Transaction();
        transaction.add(...instructions);
        transaction.add(...cleanupInstructions);
        return { transaction, signers, payer: owner };
    }
    async makeAddSingleSidedLiquidityTransaction(connection, owner, sourceTokenAccount, poolTokenAccount) {
        var _a;
        assert_1.default(this._decoded.curve.constantPrice, 'Only implemented for constant price pools');
        // @ts-ignore
        const ownerAddress = (_a = owner.publicKey) !== null && _a !== void 0 ? _a : owner;
        const instructions = [];
        const cleanupInstructions = [];
        const signers = [];
        const poolMint = await this.getCachedMintAccount(connection, this._poolTokenMint, 0);
        if (!poolMint.mintAuthority) {
            throw new Error('Mint doesnt have authority');
        }
        const authority = poolMint.mintAuthority;
        const accountRentExempt = await connection.getMinimumBalanceForRentExemption(spl_token_1.AccountLayout.span);
        const accountA = await this.getCachedTokenAccount(connection, this._holdingAccounts[0]);
        const accountB = await this.getCachedTokenAccount(connection, this._holdingAccounts[1]);
        const reserve0 = accountA.info.amount.toNumber();
        const reserve1 = accountB.info.amount.toNumber();
        const supply = poolMint.supply.toNumber();
        const tokenBPrice = this._decoded.curve.constantPrice.token_b_price;
        let price;
        if (sourceTokenAccount.mint.equals(this.tokenMints[1])) {
            price = tokenBPrice;
        }
        else {
            price = 1;
        }
        const sourceAmountPostFees = sourceTokenAccount.amount - (Math.max(1, sourceTokenAccount.amount / 2) *
            this._decoded.fees.tradeFeeNumerator / this._decoded.fees.tradeFeeDenominator);
        const liquidity = Math.floor((sourceAmountPostFees * price * supply) / (reserve0 + reserve1 * tokenBPrice));
        let fromKey;
        if (sourceTokenAccount.mint.equals(instructions_1.WRAPPED_SOL_MINT)) {
            const { account, instructions: createWrappedSolInstructions, cleanUpInstructions: removeWrappedSolInstructions, } = exports.createTokenAccount(ownerAddress, ownerAddress, instructions_1.WRAPPED_SOL_MINT, sourceTokenAccount.amount + accountRentExempt);
            fromKey = account.publicKey;
            signers.push(account);
            instructions.push(...createWrappedSolInstructions);
            cleanupInstructions.push(...removeWrappedSolInstructions);
        }
        else {
            fromKey = sourceTokenAccount.tokenAccount;
        }
        let toAccount;
        if (!poolTokenAccount) {
            const { account, instructions: createToAccountInstructions, cleanUpInstructions: cleanupCreateToAccountInstructions, } = exports.createTokenAccount(ownerAddress, ownerAddress, this._poolTokenMint, accountRentExempt);
            toAccount = account.publicKey;
            signers.push(account);
            instructions.push(...createToAccountInstructions);
            cleanupInstructions.push(...cleanupCreateToAccountInstructions);
        }
        else {
            toAccount = poolTokenAccount;
        }
        const transferAuthority = exports.approveTransfer(instructions, cleanupInstructions, fromKey, ownerAddress, sourceTokenAccount.amount, this.isLatest ? undefined : authority);
        if (this.isLatest) {
            signers.push(transferAuthority);
        }
        instructions.push(instructions_1.depositExactOneInstruction(this._poolAccount, authority, transferAuthority.publicKey, sourceTokenAccount.tokenAccount, this._holdingAccounts[0], this._holdingAccounts[1], this._poolTokenMint, toAccount, this._programId, instructions_1.TOKEN_PROGRAM_ID, sourceTokenAccount.amount, liquidity, this.isLatest));
        const transaction = new web3_js_1.Transaction();
        transaction.add(...instructions);
        transaction.add(...cleanupInstructions);
        return { transaction, signers, payer: owner };
    }
    async makeWithdrawSingleSidedLiquidityTransaction(connection, owner, destinationTokenAccount, poolTokenAccount) {
        var _a;
        assert_1.default(this._decoded.curve.constantPrice, 'Only implemented for constant price pools');
        // @ts-ignore
        const ownerAddress = (_a = owner.publicKey) !== null && _a !== void 0 ? _a : owner;
        const instructions = [];
        const cleanupInstructions = [];
        const signers = [];
        const poolMint = await this.getCachedMintAccount(connection, this._poolTokenMint, 0);
        if (!poolMint.mintAuthority) {
            throw new Error('Mint doesnt have authority');
        }
        const authority = poolMint.mintAuthority;
        const accountA = await this.getCachedTokenAccount(connection, this._holdingAccounts[0]);
        const accountB = await this.getCachedTokenAccount(connection, this._holdingAccounts[1]);
        const reserve0 = accountA.info.mint.equals(destinationTokenAccount.mint) ?
            accountA.info.amount.toNumber() - destinationTokenAccount.amount :
            accountA.info.amount.toNumber();
        const reserve1 = accountB.info.mint.equals(destinationTokenAccount.mint) ?
            accountB.info.amount.toNumber() - destinationTokenAccount.amount :
            accountB.info.amount.toNumber();
        const supply = poolMint.supply.toNumber();
        const tokenBPrice = this._decoded.curve.constantPrice.token_b_price;
        let price;
        if (destinationTokenAccount.mint.equals(this.tokenMints[1])) {
            price = tokenBPrice;
        }
        else {
            price = 1;
        }
        const destinationAmountPostFees = destinationTokenAccount.amount - (Math.max(1, destinationTokenAccount.amount / 2) *
            this._decoded.fees.tradeFeeNumerator / this._decoded.fees.tradeFeeDenominator);
        const liquidityPreWithdrawalFee = Math.ceil((destinationAmountPostFees * price * supply) / (reserve0 + reserve1 * tokenBPrice));
        let liquidity = liquidityPreWithdrawalFee;
        if (this._decoded.fees.ownerWithdrawFeeDenominator > 0) {
            liquidity += liquidityPreWithdrawalFee * (this._decoded.fees.ownerWithdrawFeeNumerator / this._decoded.fees.ownerWithdrawFeeDenominator);
        }
        else {
            liquidity += 1;
        }
        const transferAuthority = exports.approveTransfer(instructions, cleanupInstructions, poolTokenAccount, ownerAddress, liquidity, this.isLatest ? undefined : authority);
        if (this.isLatest) {
            signers.push(transferAuthority);
        }
        instructions.push(instructions_1.withdrawExactOneInstruction(this._poolAccount, authority, transferAuthority.publicKey, this._poolTokenMint, poolTokenAccount, this._holdingAccounts[0], this._holdingAccounts[1], destinationTokenAccount.tokenAccount, this.feeAccount, this._programId, instructions_1.TOKEN_PROGRAM_ID, destinationTokenAccount.amount, liquidity, this.isLatest));
        const transaction = new web3_js_1.Transaction();
        transaction.add(...instructions);
        transaction.add(...cleanupInstructions);
        return { transaction, signers, payer: owner };
    }
    async makeSwapTransaction(connection, owner, tokenIn, tokenOut, slippage, hostFeeAccount) {
        var _a;
        // @ts-ignore
        const ownerAddress = (_a = owner.publicKey) !== null && _a !== void 0 ? _a : owner;
        const [poolMint, inMint, outMint] = await Promise.all([
            this.getCachedMintAccount(connection, this._poolTokenMint, 3600000),
            this.getCachedMintAccount(connection, tokenIn.mint, 3600000),
            this.getCachedMintAccount(connection, tokenOut.mint, 3600000),
        ]);
        const amountIn = Math.floor(tokenIn.amount * Math.pow(10, inMint.decimals));
        const minAmountOut = Math.floor(tokenOut.amount * Math.pow(10, outMint.decimals) * (1 - slippage));
        const holdingA = this._tokenMints[0].toBase58() === tokenIn.mint.toBase58()
            ? this._holdingAccounts[0]
            : this._holdingAccounts[1];
        const holdingB = holdingA.equals(this._holdingAccounts[0])
            ? this._holdingAccounts[1]
            : this._holdingAccounts[0];
        if (!poolMint.mintAuthority || !this._feeAccount) {
            throw new Error('Mint doesnt have authority');
        }
        const authority = poolMint.mintAuthority;
        const instructions = [];
        const cleanupInstructions = [];
        const signers = [];
        const accountRentExempt = await connection.getMinimumBalanceForRentExemption(spl_token_1.AccountLayout.span);
        let fromAccount;
        if (tokenIn.mint.equals(instructions_1.WRAPPED_SOL_MINT)) {
            const { account, instructions: createWrappedSolInstructions, cleanUpInstructions: removeWrappedSolInstructions, } = exports.createTokenAccount(ownerAddress, ownerAddress, instructions_1.WRAPPED_SOL_MINT, amountIn + accountRentExempt);
            fromAccount = account.publicKey;
            signers.push(account);
            instructions.push(...createWrappedSolInstructions);
            cleanupInstructions.push(...removeWrappedSolInstructions);
        }
        else {
            fromAccount = tokenIn.tokenAccount;
        }
        let toAccount;
        if (tokenOut.mint.equals(instructions_1.WRAPPED_SOL_MINT)) {
            const { account, instructions: createWrappedSolInstructions, cleanUpInstructions: removeWrappedSolInstructions, } = exports.createTokenAccount(ownerAddress, ownerAddress, instructions_1.WRAPPED_SOL_MINT, accountRentExempt);
            toAccount = account.publicKey;
            signers.push(account);
            instructions.push(...createWrappedSolInstructions);
            cleanupInstructions.push(...removeWrappedSolInstructions);
        }
        else {
            toAccount = tokenOut.tokenAccount;
        }
        // create approval for transfer transactions
        const transferAuthority = exports.approveTransfer(instructions, cleanupInstructions, fromAccount, ownerAddress, amountIn, this.isLatest ? undefined : authority);
        if (this.isLatest) {
            signers.push(transferAuthority);
        }
        // swap
        instructions.push(instructions_1.swapInstruction(this._poolAccount, authority, transferAuthority.publicKey, fromAccount, holdingA, holdingB, toAccount, this._poolTokenMint, this._feeAccount, this._programId, instructions_1.TOKEN_PROGRAM_ID, amountIn, minAmountOut, hostFeeAccount));
        instructions.push(...cleanupInstructions);
        const transaction = new web3_js_1.Transaction();
        transaction.add(...instructions);
        return { transaction, signers, payer: owner };
    }
    async swap(connection, owner, tokenIn, tokenOut, slippage, hostFeeAccount, skipPreflight = true, commitment = 'single') {
        const { transaction, signers, payer } = await this.makeSwapTransaction(connection, owner, tokenIn, tokenOut, slippage, hostFeeAccount);
        return await sendTransaction(connection, transaction, [payer, ...signers], skipPreflight, commitment);
    }
    /**
     * Note: for seed param, this must be <= 32 characters for the txn to succeed
     */
    static async makeInitializePoolTransaction(connection, tokenSwapProgram, owner, componentMints, sourceTokenAccounts, options, liquidityTokenPrecision = instructions_1.DEFAULT_LIQUIDITY_TOKEN_PRECISION, accounts, seed) {
        var _a;
        // @ts-ignore
        const ownerAddress = (_a = owner.publicKey) !== null && _a !== void 0 ? _a : owner;
        const initializeAccountsInstructions = [];
        const initializeAccountsSigners = [];
        const liquidityTokenMintAccount = (accounts === null || accounts === void 0 ? void 0 : accounts.liquidityTokenMint) ? accounts.liquidityTokenMint
            : new web3_js_1.Account();
        initializeAccountsInstructions.push(web3_js_1.SystemProgram.createAccount({
            fromPubkey: ownerAddress,
            newAccountPubkey: liquidityTokenMintAccount.publicKey,
            lamports: await connection.getMinimumBalanceForRentExemption(spl_token_1.MintLayout.span),
            space: spl_token_1.MintLayout.span,
            programId: instructions_1.TOKEN_PROGRAM_ID,
        }));
        initializeAccountsSigners.push(liquidityTokenMintAccount);
        let tokenSwapAccountPubkey;
        let tokenSwapAccountSigner;
        if (accounts === null || accounts === void 0 ? void 0 : accounts.tokenSwapPoolAddress) {
            tokenSwapAccountPubkey = accounts.tokenSwapPoolAddress.publicKey;
            tokenSwapAccountSigner = accounts.tokenSwapPoolAddress;
        }
        else if (seed) {
            // Only works when owner is of type Account
            tokenSwapAccountSigner = owner;
            tokenSwapAccountPubkey = await web3_js_1.PublicKey.createWithSeed(ownerAddress, seed, tokenSwapProgram);
        }
        else {
            tokenSwapAccountSigner = new web3_js_1.Account();
            tokenSwapAccountPubkey = tokenSwapAccountSigner.pubkey;
        }
        const [authority, nonce] = await web3_js_1.PublicKey.findProgramAddress([tokenSwapAccountPubkey.toBuffer()], tokenSwapProgram);
        // create mint for pool liquidity token
        initializeAccountsInstructions.push(spl_token_1.Token.createInitMintInstruction(instructions_1.TOKEN_PROGRAM_ID, liquidityTokenMintAccount.publicKey, liquidityTokenPrecision, 
        // pass control of liquidity mint to swap program
        authority, 
        // swap program can freeze liquidity token mint
        null));
        const accountRentExempt = await connection.getMinimumBalanceForRentExemption(spl_token_1.AccountLayout.span);
        const holdingAccounts = {};
        componentMints.forEach(mint => {
            const { account, instructions: createHoldingTokenAccountInstructions, } = exports.createTokenAccount(authority, ownerAddress, mint, accountRentExempt);
            initializeAccountsInstructions.push(...createHoldingTokenAccountInstructions);
            initializeAccountsSigners.push(account);
            holdingAccounts[mint.toBase58()] = account;
        });
        const { account: depositorAccount, instructions: createLPTokenAccountInstructions, } = exports.createTokenAccount(ownerAddress, ownerAddress, liquidityTokenMintAccount.publicKey, accountRentExempt);
        initializeAccountsSigners.push(depositorAccount);
        initializeAccountsInstructions.push(...createLPTokenAccountInstructions);
        const { account: feeAccount, instructions: createFeeAccountInstructions, } = exports.createTokenAccount(instructions_1.SWAP_PROGRAM_OWNER_FEE_ADDRESS, ownerAddress, liquidityTokenMintAccount.publicKey, accountRentExempt);
        initializeAccountsSigners.push(feeAccount);
        initializeAccountsInstructions.push(...createFeeAccountInstructions);
        const initializeAccountsTransaction = new web3_js_1.Transaction();
        initializeAccountsTransaction.add(...initializeAccountsInstructions);
        // break up these into two transactions because it does not fit in a single transaction
        const initializePoolSigners = [];
        const initializePoolInstructions = [];
        const cleanupInstructions = [];
        let initializeTokenSwapAccountInstruction;
        if (seed) {
            initializeTokenSwapAccountInstruction = web3_js_1.SystemProgram.createAccountWithSeed({
                fromPubkey: ownerAddress,
                basePubkey: ownerAddress,
                newAccountPubkey: tokenSwapAccountPubkey,
                seed: seed,
                lamports: await connection.getMinimumBalanceForRentExemption(instructions_1.getLayoutForProgramId(tokenSwapProgram).span),
                space: instructions_1.getLayoutForProgramId(tokenSwapProgram).span,
                programId: tokenSwapProgram,
            });
        }
        else {
            initializeTokenSwapAccountInstruction = web3_js_1.SystemProgram.createAccount({
                fromPubkey: ownerAddress,
                newAccountPubkey: tokenSwapAccountPubkey,
                lamports: await connection.getMinimumBalanceForRentExemption(instructions_1.getLayoutForProgramId(tokenSwapProgram).span),
                space: instructions_1.getLayoutForProgramId(tokenSwapProgram).span,
                programId: tokenSwapProgram,
            });
        }
        initializePoolInstructions.push(initializeTokenSwapAccountInstruction);
        sourceTokenAccounts.forEach(({ mint, tokenAccount, amount }) => {
            let wrappedAccount;
            if (mint.equals(instructions_1.WRAPPED_SOL_MINT)) {
                const { account, instructions: createWrappedSolInstructions, cleanUpInstructions: removeWrappedSolInstructions, } = exports.createTokenAccount(ownerAddress, ownerAddress, instructions_1.WRAPPED_SOL_MINT, amount + accountRentExempt);
                wrappedAccount = account.publicKey;
                initializePoolSigners.push(account);
                initializePoolInstructions.push(...createWrappedSolInstructions);
                cleanupInstructions.push(...removeWrappedSolInstructions);
            }
            else {
                wrappedAccount = tokenAccount;
            }
            initializePoolInstructions.push(spl_token_1.Token.createTransferInstruction(instructions_1.TOKEN_PROGRAM_ID, wrappedAccount, holdingAccounts[mint.toBase58()].publicKey, ownerAddress, [], amount));
        });
        initializePoolInstructions.push(instructions_1.createInitSwapInstruction(tokenSwapAccountPubkey, authority, holdingAccounts[sourceTokenAccounts[0].mint.toBase58()].publicKey, holdingAccounts[sourceTokenAccounts[1].mint.toBase58()].publicKey, liquidityTokenMintAccount.publicKey, feeAccount.publicKey, depositorAccount.publicKey, instructions_1.TOKEN_PROGRAM_ID, tokenSwapProgram, nonce, options));
        initializePoolSigners.push(tokenSwapAccountSigner);
        const initializePoolTransaction = new web3_js_1.Transaction();
        initializePoolTransaction.add(...initializePoolInstructions, ...cleanupInstructions);
        return {
            initializeAccountsTransaction,
            initializeAccountsSigners,
            initializePoolTransaction,
            initializePoolSigners,
        };
    }
    static async initializePool(connection, tokenSwapProgram, owner, componentMints, sourceTokenAccounts, options, liquidityTokenPrecision = instructions_1.DEFAULT_LIQUIDITY_TOKEN_PRECISION, skipPreflight = true, commitment = 'single') {
        const { initializeAccountsTransaction, initializeAccountsSigners, initializePoolTransaction, initializePoolSigners, } = await Pool.makeInitializePoolTransaction(connection, tokenSwapProgram, owner, componentMints, sourceTokenAccounts, options, liquidityTokenPrecision);
        const createAccountsTxid = await sendTransaction(connection, initializeAccountsTransaction, [owner, ...initializeAccountsSigners], skipPreflight, commitment);
        const status = (await connection.confirmTransaction(createAccountsTxid))
            .value;
        assert_1.default(!status.err, `Received error awaiting create accounts transaction ${createAccountsTxid}`);
        return await sendTransaction(connection, initializePoolTransaction, [owner, ...initializePoolSigners], skipPreflight, commitment);
    }
    async removeLiquidity(connection, owner, liquidityAmount, poolAccount, tokenAccounts, skipPreflight = true, commitment = 'single') {
        const { transaction, signers } = await this.makeRemoveLiquidityTransaction(connection, owner, liquidityAmount, poolAccount, tokenAccounts);
        return await sendTransaction(connection, transaction, [owner, ...signers], skipPreflight, commitment);
    }
    async addLiquidity(connection, owner, sourceTokenAccounts, poolTokenAccount, slippageTolerance, skipPreflight = true, commitment = 'single') {
        const { transaction, signers } = await this.makeAddLiquidityTransaction(connection, owner, sourceTokenAccounts, poolTokenAccount, slippageTolerance);
        return await sendTransaction(connection, transaction, [owner, ...signers], skipPreflight, commitment);
    }
    async getHoldings(connection) {
        const accounts = await Promise.all([
            this.getCachedTokenAccount(connection, this._holdingAccounts[0]),
            this.getCachedTokenAccount(connection, this._holdingAccounts[1]),
        ]);
        return accounts.map(account => {
            return {
                account: account.pubkey,
                mint: account.info.mint,
                holding: account.info.amount,
            };
        });
    }
    get fees() {
        if (this.programVersion !== 2) {
            return {
                tradeFee: utils_1.divideBnToNumber(new bn_js_1.default(this._decoded.tradeFeeNumerator, 'le'), new bn_js_1.default(this._decoded.tradeFeeDenominator, 'le')),
                ownerFee: utils_1.divideBnToNumber(new bn_js_1.default(this._decoded.ownerTradeFeeNumerator, 'le'), new bn_js_1.default(this._decoded.ownerTradeFeeDenominator, 'le')),
                withdrawFee: utils_1.divideBnToNumber(new bn_js_1.default(this._decoded.ownerWithdrawFeeNumerator, 'le'), new bn_js_1.default(this._decoded.ownerWithdrawFeeDenominator, 'le')),
            };
        }
        else {
            let withdrawalFee;
            if (this._decoded.fees.ownerWithdrawFeeNumerator != 0 &&
                this._decoded.fees.ownerWithdrawFeeDenominator != 0) {
                withdrawalFee = utils_1.divideBnToNumber(new bn_js_1.default(this._decoded.fees.ownerWithdrawFeeNumerator, 'le'), new bn_js_1.default(this._decoded.fees.ownerWithdrawFeeDenominator, 'le'));
            }
            else {
                withdrawalFee = 0;
            }
            return {
                tradeFee: utils_1.divideBnToNumber(new bn_js_1.default(this._decoded.fees.tradeFeeNumerator, 'le'), new bn_js_1.default(this._decoded.fees.tradeFeeDenominator, 'le')),
                ownerFee: utils_1.divideBnToNumber(new bn_js_1.default(this._decoded.fees.ownerTradeFeeNumerator, 'le'), new bn_js_1.default(this._decoded.fees.ownerTradeFeeDenominator, 'le')),
                withdrawFee: withdrawalFee,
                hostFee: utils_1.divideBnToNumber(new bn_js_1.default(this._decoded.fees.hostFeeNumerator, 'le'), new bn_js_1.default(this._decoded.fees.hostFeeDenominator, 'le')),
            };
        }
    }
}
exports.Pool = Pool;
async function sendTransaction(connection, transaction, signers, skipPreflight = true, commitment = 'single') {
    const signature = await connection.sendTransaction(transaction, signers, {
        skipPreflight: skipPreflight,
    });
    const { value } = await connection.confirmTransaction(signature, commitment);
    if (value === null || value === void 0 ? void 0 : value.err) {
        throw new Error(JSON.stringify(value.err));
    }
    return signature;
}
exports.getMintAccount = async (connection, pubKey) => {
    const address = typeof pubKey === 'string' ? new web3_js_1.PublicKey(pubKey) : pubKey;
    const info = await connection.getAccountInfo(address);
    if (info === null) {
        throw new Error('Failed to find mint account');
    }
    return instructions_1.deserializeMint(info.data);
};
exports.getTokenAccount = async (connection, pubKey) => {
    const address = typeof pubKey === 'string' ? new web3_js_1.PublicKey(pubKey) : pubKey;
    const info = await connection.getAccountInfo(address);
    if (info === null) {
        throw new Error('Failed to find token account');
    }
    const accountInfo = instructions_1.parseTokenAccount(info.data);
    return {
        pubkey: address,
        account: info,
        info: accountInfo,
    };
};
exports.approveTransfer = (instructions, cleanupInstructions, account, owner, amount, 
// if delegate is not passed ephemeral transfer authority is used
delegate) => {
    const transferAuthority = new web3_js_1.Account();
    instructions.push(spl_token_1.Token.createApproveInstruction(instructions_1.TOKEN_PROGRAM_ID, account, delegate !== null && delegate !== void 0 ? delegate : transferAuthority.publicKey, owner, [], amount));
    cleanupInstructions.push(spl_token_1.Token.createRevokeInstruction(instructions_1.TOKEN_PROGRAM_ID, account, owner, []));
    return transferAuthority;
};
exports.createTokenAccount = (owner, payer, mint, lamports) => {
    const account = new web3_js_1.Account();
    const instructions = [];
    const cleanUpInstructions = [];
    const space = spl_token_1.AccountLayout.span;
    instructions.push(web3_js_1.SystemProgram.createAccount({
        fromPubkey: payer,
        newAccountPubkey: account.publicKey,
        lamports,
        space,
        programId: instructions_1.TOKEN_PROGRAM_ID,
    }));
    instructions.push(spl_token_1.Token.createInitAccountInstruction(instructions_1.TOKEN_PROGRAM_ID, mint, account.publicKey, owner));
    if (mint.equals(instructions_1.WRAPPED_SOL_MINT)) {
        cleanUpInstructions.push(spl_token_1.Token.createCloseAccountInstruction(instructions_1.TOKEN_PROGRAM_ID, account.publicKey, payer, owner, []));
    }
    return { account, instructions, cleanUpInstructions };
};
function throwIfNull(value, message = 'account not found') {
    if (value === null) {
        throw new Error(message);
    }
    return value;
}
//# sourceMappingURL=pools.js.map