"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseTokenAccount = exports.deserializeMint = exports.MINT_LAYOUT = exports.swapInstruction = exports.withdrawExactOneInstruction = exports.withdrawInstruction = exports.depositExactOneInstruction = exports.depositInstruction = exports.createInitSwapInstruction = exports.getCreateInitSwapInstructionV2Layout = exports.getLayoutForProgramId = exports.TokenSwapLayout = exports.TokenSwapLayoutV1 = exports.TokenSwapLayoutLegacyV0 = exports.uint64 = exports.publicKey = exports.getProgramVersion = exports.LATEST_VERSION = exports.DEFAULT_LIQUIDITY_TOKEN_PRECISION = exports.SWAP_PROGRAM_OWNER_FEE_ADDRESS = exports.WRAPPED_SOL_MINT = exports.TOKEN_PROGRAM_ID = exports.PROGRAM_ID = exports.PROGRAM_ID_V1 = exports.TokenSwap = void 0;
const spl_token_swap_1 = require("@solana/spl-token-swap");
const web3_js_1 = require("@solana/web3.js");
const buffer_layout_1 = require("buffer-layout");
const spl_token_1 = require("@solana/spl-token");
const types_1 = require("./types");
var spl_token_swap_2 = require("@solana/spl-token-swap");
Object.defineProperty(exports, "TokenSwap", { enumerable: true, get: function () { return spl_token_swap_2.TokenSwap; } });
exports.PROGRAM_ID_V1 = new web3_js_1.PublicKey('9qvG1zUp8xF1Bi4m6UdRNby1BAAuaDrUxSpv4CmRRMjL');
exports.PROGRAM_ID = new web3_js_1.PublicKey('SwaPpA9LAaLfeLi3a68M4DjnLqgtticKg6CnyNwgAC8');
exports.TOKEN_PROGRAM_ID = new web3_js_1.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');
exports.WRAPPED_SOL_MINT = new web3_js_1.PublicKey('So11111111111111111111111111111111111111112');
exports.SWAP_PROGRAM_OWNER_FEE_ADDRESS = new web3_js_1.PublicKey('HfoTxFR1Tm6kGmWgYWD6J7YHVy1UwqSULUGVLXkJqaKN');
exports.DEFAULT_LIQUIDITY_TOKEN_PRECISION = 8;
exports.LATEST_VERSION = 2;
function getProgramVersion(programId) {
    return exports.PROGRAM_ID.equals(programId) ? exports.LATEST_VERSION : 1;
}
exports.getProgramVersion = getProgramVersion;
/**
 * Layout for a public key
 */
exports.publicKey = (property = 'publicKey') => {
    const publicKeyLayout = buffer_layout_1.blob(32, property);
    const _decode = publicKeyLayout.decode.bind(publicKeyLayout);
    const _encode = publicKeyLayout.encode.bind(publicKeyLayout);
    publicKeyLayout.decode = (buffer, offset) => {
        const data = _decode(buffer, offset);
        return new web3_js_1.PublicKey(data);
    };
    publicKeyLayout.encode = (key, buffer, offset) => {
        return _encode(key.toBuffer(), buffer, offset);
    };
    return publicKeyLayout;
};
/**
 * Layout for a 64bit unsigned value
 */
exports.uint64 = (property = 'uint64') => {
    return buffer_layout_1.blob(8, property);
};
// TODO: add a proper <T> parameter to `TokenSwapLayoutLegacyV0`.
exports.TokenSwapLayoutLegacyV0 = buffer_layout_1.struct([
    buffer_layout_1.u8('isInitialized'),
    buffer_layout_1.u8('nonce'),
    exports.publicKey('tokenAccountA'),
    exports.publicKey('tokenAccountB'),
    exports.publicKey('tokenPool'),
    exports.uint64('feesNumerator'),
    exports.uint64('feesDenominator'),
]);
// TODO: add a proper <T> parameter to `TokenSwapLayout`.
exports.TokenSwapLayoutV1 = buffer_layout_1.struct([
    buffer_layout_1.u8('isInitialized'),
    buffer_layout_1.u8('nonce'),
    exports.publicKey('tokenProgramId'),
    exports.publicKey('tokenAccountA'),
    exports.publicKey('tokenAccountB'),
    exports.publicKey('tokenPool'),
    exports.publicKey('mintA'),
    exports.publicKey('mintB'),
    exports.publicKey('feeAccount'),
    buffer_layout_1.u8('curveType'),
    exports.uint64('tradeFeeNumerator'),
    exports.uint64('tradeFeeDenominator'),
    exports.uint64('ownerTradeFeeNumerator'),
    exports.uint64('ownerTradeFeeDenominator'),
    exports.uint64('ownerWithdrawFeeNumerator'),
    exports.uint64('ownerWithdrawFeeDenominator'),
    buffer_layout_1.blob(16, 'padding'),
]);
const FEE_LAYOUT = buffer_layout_1.struct([
    buffer_layout_1.nu64('tradeFeeNumerator'),
    buffer_layout_1.nu64('tradeFeeDenominator'),
    buffer_layout_1.nu64('ownerTradeFeeNumerator'),
    buffer_layout_1.nu64('ownerTradeFeeDenominator'),
    buffer_layout_1.nu64('ownerWithdrawFeeNumerator'),
    buffer_layout_1.nu64('ownerWithdrawFeeDenominator'),
    buffer_layout_1.nu64('hostFeeNumerator'),
    buffer_layout_1.nu64('hostFeeDenominator'),
], 'fees');
const CURVE_NODE = buffer_layout_1.union(buffer_layout_1.u8(), buffer_layout_1.blob(32), 'curve');
CURVE_NODE.addVariant(0, buffer_layout_1.struct([]), 'constantProduct');
CURVE_NODE.addVariant(1, buffer_layout_1.struct([buffer_layout_1.nu64('token_b_price')]), 'constantPrice');
CURVE_NODE.addVariant(2, buffer_layout_1.struct([]), 'stable');
CURVE_NODE.addVariant(3, buffer_layout_1.struct([buffer_layout_1.nu64('token_b_offset')]), 'offset');
exports.TokenSwapLayout = buffer_layout_1.struct([
    buffer_layout_1.u8('version'),
    buffer_layout_1.u8('isInitialized'),
    buffer_layout_1.u8('nonce'),
    exports.publicKey('tokenProgramId'),
    exports.publicKey('tokenAccountA'),
    exports.publicKey('tokenAccountB'),
    exports.publicKey('tokenPool'),
    exports.publicKey('mintA'),
    exports.publicKey('mintB'),
    exports.publicKey('feeAccount'),
    FEE_LAYOUT,
    CURVE_NODE,
]);
function getLayoutForProgramId(programId) {
    if (getProgramVersion(programId) == 2) {
        return exports.TokenSwapLayout;
    }
    else if (getProgramVersion(programId) == 1) {
        return exports.TokenSwapLayoutV1;
    }
    return exports.TokenSwapLayoutLegacyV0;
}
exports.getLayoutForProgramId = getLayoutForProgramId;
function getCreateInitSwapInstructionV2Layout(config) {
    const fields = [
        buffer_layout_1.u8('instruction'),
        buffer_layout_1.u8('nonce'),
        buffer_layout_1.nu64('tradeFeeNumerator'),
        buffer_layout_1.nu64('tradeFeeDenominator'),
        buffer_layout_1.nu64('ownerTradeFeeNumerator'),
        buffer_layout_1.nu64('ownerTradeFeeDenominator'),
        buffer_layout_1.nu64('ownerWithdrawFeeNumerator'),
        buffer_layout_1.nu64('ownerWithdrawFeeDenominator'),
        buffer_layout_1.nu64('hostFeeNumerator'),
        buffer_layout_1.nu64('hostFeeDenominator'),
        buffer_layout_1.u8('curveType'),
    ];
    if (config.curveType === types_1.CurveType.ConstantProductWithOffset) {
        fields.push(buffer_layout_1.nu64('token_b_offset'));
        fields.push(buffer_layout_1.blob(24, 'padding'));
    }
    else if (config.curveType === types_1.CurveType.ConstantPrice) {
        fields.push(buffer_layout_1.nu64('token_b_price'));
        fields.push(buffer_layout_1.blob(24, 'padding'));
    }
    else {
        fields.push(buffer_layout_1.blob(32, 'padding'));
    }
    return buffer_layout_1.struct(fields);
}
exports.getCreateInitSwapInstructionV2Layout = getCreateInitSwapInstructionV2Layout;
exports.createInitSwapInstruction = (tokenSwapAccount, authority, tokenAccountA, tokenAccountB, tokenPool, feeAccount, tokenAccountPool, tokenProgramId, swapProgramId, nonce, config) => {
    const keys = [
        { pubkey: tokenSwapAccount, isSigner: false, isWritable: true },
        { pubkey: authority, isSigner: false, isWritable: false },
        { pubkey: tokenAccountA, isSigner: false, isWritable: false },
        { pubkey: tokenAccountB, isSigner: false, isWritable: false },
        { pubkey: tokenPool, isSigner: false, isWritable: true },
        { pubkey: feeAccount, isSigner: false, isWritable: false },
        { pubkey: tokenAccountPool, isSigner: false, isWritable: true },
        { pubkey: tokenProgramId, isSigner: false, isWritable: false },
    ];
    let data = Buffer.alloc(1024);
    if (getProgramVersion(swapProgramId) === exports.LATEST_VERSION) {
        const commandDataLayout = getCreateInitSwapInstructionV2Layout(config);
        const { fees, ...rest } = config;
        const encodeLength = commandDataLayout.encode({
            instruction: 0,
            nonce,
            ...fees,
            ...rest,
        }, data);
        data = data.slice(0, encodeLength);
    }
    else {
        const commandDataLayout = buffer_layout_1.struct([
            buffer_layout_1.u8('instruction'),
            buffer_layout_1.u8('nonce'),
            buffer_layout_1.u8('curveType'),
            buffer_layout_1.nu64('tradeFeeNumerator'),
            buffer_layout_1.nu64('tradeFeeDenominator'),
            buffer_layout_1.nu64('ownerTradeFeeNumerator'),
            buffer_layout_1.nu64('ownerTradeFeeDenominator'),
            buffer_layout_1.nu64('ownerWithdrawFeeNumerator'),
            buffer_layout_1.nu64('ownerWithdrawFeeDenominator'),
            buffer_layout_1.blob(16, 'padding'),
        ]);
        const encodeLength = commandDataLayout.encode({
            instruction: 0,
            nonce,
            curveType: config.curveType,
            tradeFeeNumerator: config.fees.tradeFeeNumerator,
            tradeFeeDenominator: config.fees.tradeFeeDenominator,
            ownerTradeFeeNumerator: config.fees.ownerTradeFeeNumerator,
            ownerTradeFeeDenominator: config.fees.ownerTradeFeeDenominator,
            ownerWithdrawFeeNumerator: config.fees.ownerWithdrawFeeNumerator,
            ownerWithdrawFeeDenominator: config.fees.ownerWithdrawFeeDenominator,
        }, data);
        data = data.slice(0, encodeLength);
    }
    return new web3_js_1.TransactionInstruction({
        keys,
        programId: swapProgramId,
        data,
    });
};
exports.depositInstruction = (tokenSwap, authority, transferAuthority, sourceA, sourceB, intoA, intoB, poolToken, poolAccount, swapProgramId, tokenProgramId, poolTokenAmount, maximumTokenA, maximumTokenB) => {
    const dataLayout = buffer_layout_1.struct([
        buffer_layout_1.u8('instruction'),
        exports.uint64('poolTokenAmount'),
        exports.uint64('maximumTokenA'),
        exports.uint64('maximumTokenB'),
    ]);
    const data = Buffer.alloc(dataLayout.span);
    dataLayout.encode({
        instruction: 2,
        poolTokenAmount: new spl_token_swap_1.Numberu64(poolTokenAmount).toBuffer(),
        maximumTokenA: new spl_token_swap_1.Numberu64(maximumTokenA).toBuffer(),
        maximumTokenB: new spl_token_swap_1.Numberu64(maximumTokenB).toBuffer(),
    }, data);
    const keysByVersion = {
        1: [
            { pubkey: tokenSwap, isSigner: false, isWritable: false },
            { pubkey: authority, isSigner: false, isWritable: false },
            { pubkey: sourceA, isSigner: false, isWritable: true },
            { pubkey: sourceB, isSigner: false, isWritable: true },
            { pubkey: intoA, isSigner: false, isWritable: true },
            { pubkey: intoB, isSigner: false, isWritable: true },
            { pubkey: poolToken, isSigner: false, isWritable: true },
            { pubkey: poolAccount, isSigner: false, isWritable: true },
            { pubkey: tokenProgramId, isSigner: false, isWritable: false },
        ],
        2: [
            { pubkey: tokenSwap, isSigner: false, isWritable: false },
            { pubkey: authority, isSigner: false, isWritable: false },
            { pubkey: transferAuthority, isSigner: true, isWritable: false },
            { pubkey: sourceA, isSigner: false, isWritable: true },
            { pubkey: sourceB, isSigner: false, isWritable: true },
            { pubkey: intoA, isSigner: false, isWritable: true },
            { pubkey: intoB, isSigner: false, isWritable: true },
            { pubkey: poolToken, isSigner: false, isWritable: true },
            { pubkey: poolAccount, isSigner: false, isWritable: true },
            { pubkey: tokenProgramId, isSigner: false, isWritable: false },
        ],
    };
    const keys = keysByVersion[getProgramVersion(swapProgramId)];
    return new web3_js_1.TransactionInstruction({
        keys,
        programId: swapProgramId,
        data,
    });
};
exports.depositExactOneInstruction = (tokenSwap, authority, transferAuthority, source, intoA, intoB, poolToken, poolAccount, swapProgramId, tokenProgramId, sourceTokenAmount, minimumPoolTokenAmount, isLatest) => {
    const dataLayout = buffer_layout_1.struct([
        buffer_layout_1.u8('instruction'),
        exports.uint64('sourceTokenAmount'),
        exports.uint64('minimumPoolTokenAmount'),
    ]);
    const data = Buffer.alloc(dataLayout.span);
    dataLayout.encode({
        instruction: 4,
        sourceTokenAmount: new spl_token_swap_1.Numberu64(sourceTokenAmount).toBuffer(),
        minimumPoolTokenAmount: new spl_token_swap_1.Numberu64(minimumPoolTokenAmount).toBuffer(),
    }, data);
    const keys = isLatest
        ? [
            { pubkey: tokenSwap, isSigner: false, isWritable: false },
            { pubkey: authority, isSigner: false, isWritable: false },
            { pubkey: transferAuthority, isSigner: true, isWritable: false },
            { pubkey: source, isSigner: false, isWritable: true },
            { pubkey: intoA, isSigner: false, isWritable: true },
            { pubkey: intoB, isSigner: false, isWritable: true },
            { pubkey: poolToken, isSigner: false, isWritable: true },
            { pubkey: poolAccount, isSigner: false, isWritable: true },
            { pubkey: tokenProgramId, isSigner: false, isWritable: false },
        ]
        : [
            { pubkey: tokenSwap, isSigner: false, isWritable: false },
            { pubkey: authority, isSigner: false, isWritable: false },
            { pubkey: source, isSigner: false, isWritable: true },
            { pubkey: intoA, isSigner: false, isWritable: true },
            { pubkey: intoB, isSigner: false, isWritable: true },
            { pubkey: poolToken, isSigner: false, isWritable: true },
            { pubkey: poolAccount, isSigner: false, isWritable: true },
            { pubkey: tokenProgramId, isSigner: false, isWritable: false },
        ];
    return new web3_js_1.TransactionInstruction({
        keys,
        programId: swapProgramId,
        data,
    });
};
exports.withdrawInstruction = (tokenSwap, authority, transferAuthority, poolMint, feeAccount, sourcePoolAccount, fromA, fromB, userAccountA, userAccountB, swapProgramId, tokenProgramId, poolTokenAmount, minimumTokenA, minimumTokenB) => {
    const dataLayout = buffer_layout_1.struct([
        buffer_layout_1.u8('instruction'),
        exports.uint64('poolTokenAmount'),
        exports.uint64('minimumTokenA'),
        exports.uint64('minimumTokenB'),
    ]);
    const data = Buffer.alloc(dataLayout.span);
    dataLayout.encode({
        instruction: 3,
        poolTokenAmount: new spl_token_swap_1.Numberu64(poolTokenAmount).toBuffer(),
        minimumTokenA: new spl_token_swap_1.Numberu64(minimumTokenA).toBuffer(),
        minimumTokenB: new spl_token_swap_1.Numberu64(minimumTokenB).toBuffer(),
    }, data);
    const keysByVersion = {
        1: [
            { pubkey: tokenSwap, isSigner: false, isWritable: false },
            { pubkey: authority, isSigner: false, isWritable: false },
            { pubkey: poolMint, isSigner: false, isWritable: true },
            { pubkey: sourcePoolAccount, isSigner: false, isWritable: true },
            { pubkey: fromA, isSigner: false, isWritable: true },
            { pubkey: fromB, isSigner: false, isWritable: true },
            { pubkey: userAccountA, isSigner: false, isWritable: true },
            { pubkey: userAccountB, isSigner: false, isWritable: true },
        ],
        2: [
            { pubkey: tokenSwap, isSigner: false, isWritable: false },
            { pubkey: authority, isSigner: false, isWritable: false },
            { pubkey: transferAuthority, isSigner: true, isWritable: false },
            { pubkey: poolMint, isSigner: false, isWritable: true },
            { pubkey: sourcePoolAccount, isSigner: false, isWritable: true },
            { pubkey: fromA, isSigner: false, isWritable: true },
            { pubkey: fromB, isSigner: false, isWritable: true },
            { pubkey: userAccountA, isSigner: false, isWritable: true },
            { pubkey: userAccountB, isSigner: false, isWritable: true },
        ],
    };
    const keys = keysByVersion[getProgramVersion(swapProgramId)];
    if (feeAccount) {
        keys.push({ pubkey: feeAccount, isSigner: false, isWritable: true });
    }
    keys.push({ pubkey: tokenProgramId, isSigner: false, isWritable: false });
    return new web3_js_1.TransactionInstruction({
        keys,
        programId: swapProgramId,
        data,
    });
};
exports.withdrawExactOneInstruction = (tokenSwap, authority, transferAuthority, poolMint, sourcePoolAccount, fromA, fromB, userAccount, feeAccount, swapProgramId, tokenProgramId, sourceTokenAmount, maximumTokenAmount, isLatest) => {
    const dataLayout = buffer_layout_1.struct([
        buffer_layout_1.u8('instruction'),
        exports.uint64('sourceTokenAmount'),
        exports.uint64('maximumTokenAmount'),
    ]);
    const data = Buffer.alloc(dataLayout.span);
    dataLayout.encode({
        instruction: 5,
        sourceTokenAmount: new spl_token_swap_1.Numberu64(sourceTokenAmount).toBuffer(),
        maximumTokenAmount: new spl_token_swap_1.Numberu64(maximumTokenAmount).toBuffer(),
    }, data);
    const keys = isLatest
        ? [
            { pubkey: tokenSwap, isSigner: false, isWritable: false },
            { pubkey: authority, isSigner: false, isWritable: false },
            { pubkey: transferAuthority, isSigner: true, isWritable: false },
            { pubkey: poolMint, isSigner: false, isWritable: true },
            { pubkey: sourcePoolAccount, isSigner: false, isWritable: true },
            { pubkey: fromA, isSigner: false, isWritable: true },
            { pubkey: fromB, isSigner: false, isWritable: true },
            { pubkey: userAccount, isSigner: false, isWritable: true },
        ]
        : [
            { pubkey: tokenSwap, isSigner: false, isWritable: false },
            { pubkey: authority, isSigner: false, isWritable: false },
            { pubkey: poolMint, isSigner: false, isWritable: true },
            { pubkey: sourcePoolAccount, isSigner: false, isWritable: true },
            { pubkey: fromA, isSigner: false, isWritable: true },
            { pubkey: fromB, isSigner: false, isWritable: true },
            { pubkey: userAccount, isSigner: false, isWritable: true },
        ];
    if (feeAccount) {
        keys.push({ pubkey: feeAccount, isSigner: false, isWritable: true });
    }
    keys.push({ pubkey: tokenProgramId, isSigner: false, isWritable: false });
    return new web3_js_1.TransactionInstruction({
        keys,
        programId: swapProgramId,
        data,
    });
};
exports.swapInstruction = (tokenSwap, authority, transferAuthority, userSource, poolSource, poolDestination, userDestination, poolMint, feeAccount, swapProgramId, tokenProgramId, amountIn, minimumAmountOut, programOwner) => {
    const dataLayout = buffer_layout_1.struct([
        buffer_layout_1.u8('instruction'),
        exports.uint64('amountIn'),
        exports.uint64('minimumAmountOut'),
    ]);
    const keysByVersion = {
        1: [
            { pubkey: tokenSwap, isSigner: false, isWritable: false },
            { pubkey: authority, isSigner: false, isWritable: false },
            { pubkey: userSource, isSigner: false, isWritable: true },
            { pubkey: poolSource, isSigner: false, isWritable: true },
            { pubkey: poolDestination, isSigner: false, isWritable: true },
            { pubkey: userDestination, isSigner: false, isWritable: true },
            { pubkey: poolMint, isSigner: false, isWritable: true },
            { pubkey: feeAccount, isSigner: false, isWritable: true },
            { pubkey: tokenProgramId, isSigner: false, isWritable: false },
        ],
        2: [
            { pubkey: tokenSwap, isSigner: false, isWritable: false },
            { pubkey: authority, isSigner: false, isWritable: false },
            { pubkey: transferAuthority, isSigner: true, isWritable: false },
            { pubkey: userSource, isSigner: false, isWritable: true },
            { pubkey: poolSource, isSigner: false, isWritable: true },
            { pubkey: poolDestination, isSigner: false, isWritable: true },
            { pubkey: userDestination, isSigner: false, isWritable: true },
            { pubkey: poolMint, isSigner: false, isWritable: true },
            { pubkey: feeAccount, isSigner: false, isWritable: true },
            { pubkey: tokenProgramId, isSigner: false, isWritable: false },
        ],
    };
    const keys = keysByVersion[getProgramVersion(swapProgramId)];
    // optional depending on the build of token-swap program
    if (programOwner) {
        keys.push({ pubkey: programOwner, isSigner: false, isWritable: true });
    }
    const data = Buffer.alloc(dataLayout.span);
    dataLayout.encode({
        instruction: 1,
        amountIn: new spl_token_swap_1.Numberu64(amountIn).toBuffer(),
        minimumAmountOut: new spl_token_swap_1.Numberu64(minimumAmountOut).toBuffer(),
    }, data);
    return new web3_js_1.TransactionInstruction({
        keys,
        programId: swapProgramId,
        data,
    });
};
exports.MINT_LAYOUT = buffer_layout_1.struct([
    buffer_layout_1.blob(4),
    buffer_layout_1.blob(32, 'mintAuthority'),
    buffer_layout_1.blob(8, 'supply'),
    buffer_layout_1.u8('decimals'),
    buffer_layout_1.u8('isInitialized'),
    buffer_layout_1.blob(4, 'freezeAuthorityOption'),
    buffer_layout_1.blob(32, 'freezeAuthority'),
]);
exports.deserializeMint = (data) => {
    if (data.length !== spl_token_1.MintLayout.span) {
        throw new Error('Not a valid Mint');
    }
    const mintInfo = spl_token_1.MintLayout.decode(data);
    if (mintInfo.mintAuthorityOption === 0) {
        mintInfo.mintAuthority = null;
    }
    else {
        mintInfo.mintAuthority = new web3_js_1.PublicKey(mintInfo.mintAuthority);
    }
    mintInfo.supply = spl_token_1.u64.fromBuffer(mintInfo.supply);
    mintInfo.isInitialized = mintInfo.isInitialized !== 0;
    if (mintInfo.freezeAuthorityOption === 0) {
        mintInfo.freezeAuthority = null;
    }
    else {
        mintInfo.freezeAuthority = new web3_js_1.PublicKey(mintInfo.freezeAuthority);
    }
    return mintInfo;
};
function parseTokenAccount(data) {
    const accountInfo = spl_token_1.AccountLayout.decode(data);
    accountInfo.mint = new web3_js_1.PublicKey(accountInfo.mint);
    accountInfo.owner = new web3_js_1.PublicKey(accountInfo.owner);
    accountInfo.amount = spl_token_1.u64.fromBuffer(accountInfo.amount);
    if (accountInfo.delegateOption === 0) {
        accountInfo.delegate = null;
        // eslint-disable-next-line new-cap
        accountInfo.delegatedAmount = new spl_token_1.u64(0);
    }
    else {
        accountInfo.delegate = new web3_js_1.PublicKey(accountInfo.delegate);
        accountInfo.delegatedAmount = spl_token_1.u64.fromBuffer(accountInfo.delegatedAmount);
    }
    accountInfo.isInitialized = accountInfo.state !== 0;
    accountInfo.isFrozen = accountInfo.state === 2;
    if (accountInfo.isNativeOption === 1) {
        accountInfo.rentExemptReserve = spl_token_1.u64.fromBuffer(accountInfo.isNative);
        accountInfo.isNative = true;
    }
    else {
        accountInfo.rentExemptReserve = null;
        accountInfo.isNative = false;
    }
    if (accountInfo.closeAuthorityOption === 0) {
        accountInfo.closeAuthority = null;
    }
    else {
        accountInfo.closeAuthority = new web3_js_1.PublicKey(accountInfo.closeAuthority);
    }
    return accountInfo;
}
exports.parseTokenAccount = parseTokenAccount;
//# sourceMappingURL=instructions.js.map