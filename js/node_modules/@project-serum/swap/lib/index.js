"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Swap = void 0;
const web3_js_1 = require("@solana/web3.js");
const anchor_1 = require("@project-serum/anchor");
const web3_js_2 = require("@solana/web3.js");
const spl_token_1 = require("@solana/spl-token");
const serum_1 = require("@project-serum/serum");
const idl_1 = require("./idl");
const utils_1 = require("./utils");
const swap_markets_1 = __importDefault(require("./swap-markets"));
// Close account feature flag.
//
// TODO: enable once the DEX supports closing open orders accounts.
const CLOSE_ENABLED = false;
// Initialize open orders feature flag.
//
// TODO: enable once the DEX supports initializing open orders accounts.
const OPEN_ENABLED = false;
/**
 *
 * # Swap
 *
 * A module to swap tokens across USD(x) quoted markets on the Serum DEX,
 * providing a thin wrapper around an
 * [Anchor](https://github.com/project-serum/anchor) for the sole purpose of
 * providing a simplified `swap` API.
 *
 * ## Usage
 *
 * ### Create a client
 *
 * ```javascript
 * const client = new Swap(provider, tokenList)
 * ```
 *
 * ### Swap one token for another.
 *
 * ```javascript
 * await client.swap({
 *   fromMint,
 *   toMint,
 *   amount,
 *   minExchangeRate,
 * });
 * ```
 *
 * ## Swap Program Basics
 *
 * One should have a basic understanding of the on-chain
 * [Swap](https://github.com/project-serum/swap) program before using the
 * client. Two core APIs are exposed.
 *
 * * [swap](https://github.com/project-serum/swap/blob/master/programs/swap/src/lib.rs#L36) -
 *   swaps two tokens on a single A/B market. This is just an IOC trade at the
 *   BBO that instantly settles.
 * * [swapTransitive](https://github.com/project-serum/swap/blob/master/programs/swap/src/lib.rs#L107) -
 *   swaps two tokens across **two** A/x, B/x markets in the same manner as
 *   `swap`.
 *
 * When swapping to/from a USD(x) token, the swap client will use the `swap` API.
 * When swapping to/from a non-USD(x) token, e.g., wBTC for wETH, the swap
 * client will use the `swapTransitive`API with USD(x) quoted markets to bridge
 * the two tokens.
 *
 * For both APIs, if the number of tokens received from the trade is less than
 * the client provided `minExchangeRate`, the transaction aborts.
 *
 * Note that if this client package is insufficient, one can always use the
 *  Anchor generated client directly, exposing an API mapping one-to-one to
 * these program instructions. See the
 * [`tests/`](https://github.com/project-serum/swap/blob/master/tests/swap.js)
 * for examples of using the Anchor generated swap client.
 *
 * ## Serum Orderbook Program Basics
 *
 * Additionally, because the Swap program is an on-chain frontend for the Serum
 * DEX, one should also be aware of the basic accounts needed for trading on
 * the Serum DEX.
 *
 * Namely, a wallet must have an "open orders" account for each market the
 * wallet trades on. The "open orders" account is akin to how a wallet
 *  must have an SPL token account to own tokens, except instead of holding
 * tokens, the wallet can make trades on the orderbook.
 *
 * ### Creating Open Orders Accounts
 *
 * When the wallet doesn't have an open orders account already created,
 * the swap client provides two choices. Automatically create the required
 * accounts by preloading the instructions in the [[swap]] transaction.
 *
 * Note that if the user is swapping between two non-USD(x) tokens, e.g., wBTC
 * for wETH, then the user needs *two* open orders accounts on both wBTC/USD(x)
 * and wETH/USD(x) markets. In the event both of these open orders accounts are
 * created for the rfirst time, then the transaction is broken up into two
 * (and `Provider.sendAll` is used) to prevent hitting transaction size limits.
 */
class Swap {
    /**
     * @param provider  The wallet and network context to use for the client.
     * @param tokenList The token list providing market addresses for each mint.
     */
    constructor(provider, tokenList) {
        this._program = new anchor_1.Program(idl_1.IDL, utils_1.SWAP_PID, provider);
        this._swapMarkets = new swap_markets_1.default(provider, tokenList);
    }
    /**
     * Anchor generated client for the swap program.
     */
    get program() {
        return this._program;
    }
    /**
     * Token list registry for fetching USD(x) markets for each mint.
     */
    get swapMarkets() {
        return this._swapMarkets;
    }
    /**
     * Returns a list of markets to trade across to swap `fromMint` to `toMint`.
     */
    route(fromMint, toMint) {
        return this.swapMarkets.route(fromMint, toMint);
    }
    /**
     * Executes a swap against the Serum DEX on Solana. When using one should
     * first use `estimate` along with a user defined error tolerance to calculate
     * the `minExchangeRate`, which provides a lower bound for the number
     * of output tokens received when executing the swap. If, for example,
     * swapping on an illiquid market and the output tokens is less than
     * `minExchangeRate`, then the transaction will fail in an attempt to
     * prevent an undesireable outcome.
     */
    async swap(params) {
        const txs = await this.swapTxs(params);
        return this.program.provider.sendAll(txs, params.options);
    }
    async swapTxs(params) {
        let { fromMint, toMint, quoteWallet, fromWallet, toWallet, fromMarket, toMarket, amount, minExchangeRate, referral, close, fromOpenOrders, toOpenOrders, } = params;
        // If either wallet isn't given, then use the associated token account.
        // Assumes the accounts are already created.
        if (!fromWallet) {
            fromWallet = await utils_1.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, fromMint, this.program.provider.wallet.publicKey);
        }
        if (!toWallet) {
            toWallet = await utils_1.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, toMint, this.program.provider.wallet.publicKey);
        }
        // If swapping to/from a USD(x) token, then swap directly on the market.
        if (fromMint.equals(utils_1.USDC_PUBKEY) || fromMint.equals(utils_1.USDT_PUBKEY)) {
            return await this.swapDirectTxs({
                coinWallet: toWallet,
                pcWallet: fromWallet,
                baseMint: toMint,
                quoteMint: fromMint,
                side: Side.Bid,
                amount,
                minExchangeRate,
                referral,
                close,
                fromMarket,
                fromOpenOrders,
            });
        }
        else if (toMint.equals(utils_1.USDC_PUBKEY) || toMint.equals(utils_1.USDT_PUBKEY)) {
            return await this.swapDirectTxs({
                coinWallet: fromWallet,
                pcWallet: toWallet,
                baseMint: fromMint,
                quoteMint: toMint,
                side: Side.Ask,
                amount,
                minExchangeRate,
                referral,
                close,
                fromMarket,
                fromOpenOrders,
            });
        }
        else if (fromMarket !== undefined && toMarket === undefined) {
            return await this.swapDirectTxs({
                coinWallet: fromWallet,
                pcWallet: toWallet,
                baseMint: fromMint,
                quoteMint: toMint,
                side: fromMint.equals(fromMarket.baseMintAddress) ? Side.Ask : Side.Bid,
                amount,
                minExchangeRate,
                referral,
                close,
                fromMarket,
                fromOpenOrders,
            });
        }
        // Neither wallet is a USD stable coin. So perform a transitive swap.
        if (!quoteWallet) {
            if (this.swapMarkets.usdcPathExists(fromMint, toMint)) {
                quoteWallet = await utils_1.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, utils_1.USDC_PUBKEY, this.program.provider.wallet.publicKey);
            }
            else {
                quoteWallet = await utils_1.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, utils_1.USDT_PUBKEY, this.program.provider.wallet.publicKey);
            }
        }
        return await this.swapTransitiveTxs({
            fromMint,
            toMint,
            fromWallet,
            toWallet,
            pcWallet: quoteWallet,
            amount,
            minExchangeRate,
            referral,
            close,
            fromMarket,
            toMarket,
            fromOpenOrders,
            toOpenOrders,
        });
    }
    async swapDirectTxs({ coinWallet, pcWallet, baseMint, quoteMint, side, amount, minExchangeRate, referral, close, fromMarket, fromOpenOrders, }) {
        const marketAddress = fromMarket
            ? fromMarket.address
            : this.swapMarkets.getMarketAddress(quoteMint, baseMint);
        if (marketAddress === null) {
            throw new Error('Invalid market');
        }
        const marketClient = fromMarket
            ? fromMarket
            : await serum_1.Market.load(this.program.provider.connection, marketAddress, this.program.provider.opts, utils_1.DEX_PID);
        const [vaultSigner] = await utils_1.getVaultOwnerAndNonce(marketClient.address);
        let openOrders;
        if (fromOpenOrders) {
            openOrders = fromOpenOrders;
        }
        else {
            openOrders = await (async () => {
                let openOrders = await serum_1.OpenOrders.findForMarketAndOwner(this.program.provider.connection, marketClient.address, this.program.provider.wallet.publicKey, utils_1.DEX_PID);
                // If we have an open orders account use it. It doesn't matter which
                // one we use.
                return openOrders[0] ? openOrders[0].address : undefined;
            })();
        }
        const needsOpenOrders = openOrders === undefined;
        const tx = new web3_js_1.Transaction();
        const signers = [];
        // Create the open orders account, if needed.
        if (needsOpenOrders) {
            const oo = new web3_js_2.Account();
            signers.push(oo);
            openOrders = oo.publicKey;
            tx.add(await serum_1.OpenOrders.makeCreateAccountTransaction(this.program.provider.connection, marketClient.address, this.program.provider.wallet.publicKey, oo.publicKey, utils_1.DEX_PID));
        }
        tx.add(this.program.instruction.swap(side, amount, minExchangeRate, {
            accounts: {
                market: {
                    market: marketClient.address,
                    // @ts-ignore
                    requestQueue: marketClient._decoded.requestQueue,
                    // @ts-ignore
                    eventQueue: marketClient._decoded.eventQueue,
                    bids: marketClient.bidsAddress,
                    asks: marketClient.asksAddress,
                    // @ts-ignore
                    coinVault: marketClient._decoded.baseVault,
                    // @ts-ignore
                    pcVault: marketClient._decoded.quoteVault,
                    vaultSigner,
                    openOrders,
                    orderPayerTokenAccount: side.bid ? pcWallet : coinWallet,
                    coinWallet: coinWallet,
                },
                pcWallet,
                authority: this.program.provider.wallet.publicKey,
                dexProgram: utils_1.DEX_PID,
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                rent: web3_js_1.SYSVAR_RENT_PUBKEY,
            },
            remainingAccounts: referral && [
                { pubkey: referral, isWritable: true, isSigner: false },
            ],
        }));
        // If an account was opened for this swap, then close it in the same
        // transaction.
        if (CLOSE_ENABLED && close && needsOpenOrders) {
            tx.add(this.program.instruction.closeAccount({
                accounts: {
                    openOrders,
                    authority: this.program.provider.wallet.publicKey,
                    destination: this.program.provider.wallet.publicKey,
                    market: marketClient.address,
                    dexProgram: utils_1.DEX_PID,
                },
            }));
        }
        return [{ tx, signers }];
    }
    async swapTransitiveTxs({ fromMint, toMint, fromWallet, toWallet, pcWallet, amount, minExchangeRate, referral, close, fromMarket, toMarket, fromOpenOrders, toOpenOrders, }) {
        // Fetch the markets, if needed.
        let fromMarketAddress, toMarketAddress;
        let fromMarketClient, toMarketClient;
        if (fromMarket) {
            fromMarketAddress = fromMarket.address;
            fromMarketClient = fromMarket;
        }
        else {
            let fromMarketAddressMaybe = this.swapMarkets.getMarketAddress(utils_1.USDC_PUBKEY, fromMint);
            if (fromMarketAddressMaybe === null) {
                fromMarketAddressMaybe = this.swapMarkets.getMarketAddress(utils_1.USDT_PUBKEY, fromMint);
                if (fromMarketAddressMaybe === null) {
                    throw new Error('Invalid market');
                }
            }
            fromMarketAddress = fromMarketAddressMaybe;
            fromMarketClient = await serum_1.Market.load(this.program.provider.connection, fromMarketAddress, this.program.provider.opts, utils_1.DEX_PID);
        }
        if (toMarket) {
            toMarketAddress = toMarket.address;
            toMarketClient = toMarket;
        }
        else {
            let toMarketAddressMaybe = this.swapMarkets.getMarketAddress(utils_1.USDC_PUBKEY, toMint);
            if (toMarketAddressMaybe === null) {
                toMarketAddressMaybe = this.swapMarkets.getMarketAddress(utils_1.USDT_PUBKEY, toMint);
                if (toMarketAddressMaybe === null) {
                    throw new Error('Invalid market');
                }
            }
            toMarketAddress = toMarketAddressMaybe;
            toMarketClient = await serum_1.Market.load(this.program.provider.connection, toMarketAddress, this.program.provider.opts, utils_1.DEX_PID);
        }
        // Fetch the open orders accounts, if needed.
        if (!fromOpenOrders) {
            const acc = await serum_1.OpenOrders.findForMarketAndOwner(this.program.provider.connection, fromMarketClient.address, this.program.provider.wallet.publicKey, utils_1.DEX_PID)[0];
            fromOpenOrders = acc ? acc.address : undefined;
        }
        if (!toOpenOrders) {
            const acc = await serum_1.OpenOrders.findForMarketAndOwner(this.program.provider.connection, toMarketClient.address, this.program.provider.wallet.publicKey, utils_1.DEX_PID)[0];
            toOpenOrders = acc ? acc.address : undefined;
        }
        // If the open orders are still undefined, then they don't exist.
        const fromNeedsOpenOrders = fromOpenOrders === undefined;
        const toNeedsOpenOrders = toOpenOrders === undefined;
        // Now that we have all the accounts, build the transaction.
        //
        // In the event the transaction would be over the transaction size limit,
        // we break up the transaction into multiple and use `Provider.sendAll`
        // as a workaround, providing a single user flow for the swap action.
        //
        // Alternatively, one could breakup the different actions here into explicit
        // user flows. I.e., three separate flows for creating open orders
        // counts, swapping, and closing open orders accounts. If choosing to do
        // this, it's recommended to use the anchor generated client directly,
        // instead of the client here.
        let openOrdersTransaction = undefined;
        const openOrdersSigners = [];
        const swapTransaction = new web3_js_1.Transaction();
        const swapSigners = [];
        let closeTransaction = undefined;
        const closeSigners = [];
        // Calculate the vault signers for each market.
        const [fromVaultSigner] = await utils_1.getVaultOwnerAndNonce(fromMarketClient.address);
        const [toVaultSigner] = await utils_1.getVaultOwnerAndNonce(toMarketClient.address);
        // Add instructions to create open orders, if needed.
        //
        // If creating open orders accounts on *both* from and to markets, then
        // split out the create open orders instructions into their own transaction.
        if (fromNeedsOpenOrders && toNeedsOpenOrders) {
            openOrdersTransaction = new web3_js_1.Transaction();
            const ooFrom = new web3_js_2.Account();
            openOrdersSigners.push(ooFrom);
            openOrdersTransaction.add(await serum_1.OpenOrders.makeCreateAccountTransaction(this.program.provider.connection, fromMarketAddress, this.program.provider.wallet.publicKey, ooFrom.publicKey, utils_1.DEX_PID));
            fromOpenOrders = ooFrom.publicKey;
            const ooTo = new web3_js_2.Account();
            openOrdersSigners.push(ooTo);
            openOrdersTransaction.add(await serum_1.OpenOrders.makeCreateAccountTransaction(this.program.provider.connection, toMarketAddress, this.program.provider.wallet.publicKey, ooTo.publicKey, utils_1.DEX_PID));
            toOpenOrders = ooTo.publicKey;
            if (OPEN_ENABLED) {
                openOrdersTransaction.add(this.program.instruction.initAccount({
                    accounts: {
                        openOrders: ooFrom.publicKey,
                        authority: this.program.provider.wallet.publicKey,
                        market: fromMarketAddress,
                        dexProgram: utils_1.DEX_PID,
                        rent: web3_js_1.SYSVAR_RENT_PUBKEY,
                    },
                }));
                openOrdersTransaction.add(this.program.instruction.initAccount({
                    accounts: {
                        openOrders: ooTo.publicKey,
                        authority: this.program.provider.wallet.publicKey,
                        market: fromMarketAddress,
                        dexProgram: utils_1.DEX_PID,
                        rent: web3_js_1.SYSVAR_RENT_PUBKEY,
                    },
                }));
            }
        }
        else if (fromNeedsOpenOrders) {
            const oo = new web3_js_2.Account();
            swapSigners.push(oo);
            swapTransaction.add(await serum_1.OpenOrders.makeCreateAccountTransaction(this.program.provider.connection, fromMarketAddress, this.program.provider.wallet.publicKey, oo.publicKey, utils_1.DEX_PID));
            fromOpenOrders = oo.publicKey;
        }
        else if (toNeedsOpenOrders) {
            const oo = new web3_js_2.Account();
            swapSigners.push(oo);
            swapTransaction.add(await serum_1.OpenOrders.makeCreateAccountTransaction(this.program.provider.connection, toMarketAddress, this.program.provider.wallet.publicKey, oo.publicKey, utils_1.DEX_PID));
            toOpenOrders = oo.publicKey;
        }
        swapTransaction.add(this.program.instruction.swapTransitive(amount, minExchangeRate, {
            accounts: {
                from: {
                    market: fromMarketClient.address,
                    // @ts-ignore
                    requestQueue: fromMarketClient._decoded.requestQueue,
                    // @ts-ignore
                    eventQueue: fromMarketClient._decoded.eventQueue,
                    bids: fromMarketClient.bidsAddress,
                    asks: fromMarketClient.asksAddress,
                    // @ts-ignore
                    coinVault: fromMarketClient._decoded.baseVault,
                    // @ts-ignore
                    pcVault: fromMarketClient._decoded.quoteVault,
                    vaultSigner: fromVaultSigner,
                    openOrders: fromOpenOrders,
                    orderPayerTokenAccount: fromWallet,
                    coinWallet: fromWallet,
                },
                to: {
                    market: toMarketClient.address,
                    // @ts-ignore
                    requestQueue: toMarketClient._decoded.requestQueue,
                    // @ts-ignore
                    eventQueue: toMarketClient._decoded.eventQueue,
                    bids: toMarketClient.bidsAddress,
                    asks: toMarketClient.asksAddress,
                    // @ts-ignore
                    coinVault: toMarketClient._decoded.baseVault,
                    // @ts-ignore
                    pcVault: toMarketClient._decoded.quoteVault,
                    vaultSigner: toVaultSigner,
                    openOrders: toOpenOrders,
                    orderPayerTokenAccount: pcWallet,
                    coinWallet: toWallet,
                },
                pcWallet,
                authority: this.program.provider.wallet.publicKey,
                dexProgram: utils_1.DEX_PID,
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                rent: web3_js_1.SYSVAR_RENT_PUBKEY,
            },
            remainingAccounts: referral && [
                { pubkey: referral, isWritable: true, isSigner: false },
            ],
        }));
        if (CLOSE_ENABLED && close && fromNeedsOpenOrders) {
            closeTransaction = new web3_js_1.Transaction();
            closeTransaction.add(this.program.instruction.closeAccount({
                accounts: {
                    openOrders: fromOpenOrders,
                    authority: this.program.provider.wallet.publicKey,
                    destination: this.program.provider.wallet.publicKey,
                    market: fromMarketClient.address,
                    dexProgram: utils_1.DEX_PID,
                },
            }));
        }
        if (CLOSE_ENABLED && close && toNeedsOpenOrders) {
            if (!closeTransaction) {
                closeTransaction = new web3_js_1.Transaction();
            }
            closeTransaction.add(this.program.instruction.closeAccount({
                accounts: {
                    openOrders: toOpenOrders,
                    authority: this.program.provider.wallet.publicKey,
                    destination: this.program.provider.wallet.publicKey,
                    market: toMarketClient.address,
                    dexProgram: utils_1.DEX_PID,
                },
            }));
        }
        const txs = [];
        if (openOrdersTransaction !== undefined) {
            txs.push({ tx: openOrdersTransaction, signers: openOrdersSigners });
        }
        txs.push({ tx: swapTransaction, signers: swapSigners });
        if (closeTransaction !== undefined) {
            txs.push({ tx: closeTransaction, signers: closeSigners });
        }
        return txs;
    }
}
exports.Swap = Swap;
const Side = {
    Bid: { bid: {} },
    Ask: { ask: {} },
};
//# sourceMappingURL=index.js.map